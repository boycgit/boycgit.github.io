
<!DOCTYPE html><html lang="zh">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>ES7 decorator 装饰者模式</title>
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" type="text/css" href="../assets/built/screen.css?v=11f1923694">

    <link rel="shortcut icon" href="../favicon.png" type="image/png">
    <link rel="canonical" href="https://boycgit.github.io/es7-decorator/">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <link rel="amphtml" href="https://boycgit.github.io/es7-decorator/amp/">
    
    <meta property="og:site_name" content="JSCON-简时空">
    <meta property="og:type" content="article">
    <meta property="og:title" content="ES7 decorator 装饰者模式">
    <meta property="og:description" content="装饰者模式 1、装饰模式 设计模式大家都有了解，网上有很多系列教程，比如 JS设计模式等等。  这里只分享 装饰者模式 以及在 如何使用 ES7 的 decorator 概念  1.1、装饰模式 v.s. 适配器模式 装饰模式和适配器模式都是“包装模式”(Wrapper Pattern)，它们都是通过封装其他对象达到设计的目的的，但是它们的形态有很大区别。  适配器模式我们使用的场景比较多，比如连接不同数据库的情况，你需要包装现有的模块接口，从而使之适配数据库 —— 好比你手机使用转接口来适配插座那样；  装饰模式不一样，仅仅包装现有的模块，使之 “更加华丽” ，并不会影响原有接口的功能 —— 好比你给手机添加一个外壳罢了，并不影响手机原有的通话、充电等功能；    更多区别参见：设计模式——装饰模式（Decorator）  1.2、装饰模式场景 —— 面向AOP编程 装饰模式经典的应用是AOP编程，比如“">
    <meta property="og:url" content="https://boycgit.github.io/es7-decorator/">
    <meta property="og:image" content="https://casper.ghost.org/v1.0.0/images/design.jpg">
    <meta property="article:published_time" content="2017-02-03T09:36:00.000Z">
    <meta property="article:modified_time" content="2018-08-17T07:57:12.000Z">
    <meta property="article:tag" content="javascript">
    <meta property="article:tag" content="教程">
    
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="ES7 decorator 装饰者模式">
    <meta name="twitter:description" content="装饰者模式 1、装饰模式 设计模式大家都有了解，网上有很多系列教程，比如 JS设计模式等等。  这里只分享 装饰者模式 以及在 如何使用 ES7 的 decorator 概念  1.1、装饰模式 v.s. 适配器模式 装饰模式和适配器模式都是“包装模式”(Wrapper Pattern)，它们都是通过封装其他对象达到设计的目的的，但是它们的形态有很大区别。  适配器模式我们使用的场景比较多，比如连接不同数据库的情况，你需要包装现有的模块接口，从而使之适配数据库 —— 好比你手机使用转接口来适配插座那样；  装饰模式不一样，仅仅包装现有的模块，使之 “更加华丽” ，并不会影响原有接口的功能 —— 好比你给手机添加一个外壳罢了，并不影响手机原有的通话、充电等功能；    更多区别参见：设计模式——装饰模式（Decorator）  1.2、装饰模式场景 —— 面向AOP编程 装饰模式经典的应用是AOP编程，比如“">
    <meta name="twitter:url" content="https://boycgit.github.io/es7-decorator/">
    <meta name="twitter:image" content="https://casper.ghost.org/v1.0.0/images/design.jpg">
    <meta name="twitter:label1" content="Written by">
    <meta name="twitter:data1" content="boycgit">
    <meta name="twitter:label2" content="Filed under">
    <meta name="twitter:data2" content="javascript, 教程">
    <meta property="og:image:width" content="1400">
    <meta property="og:image:height" content="1050">
    
    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "publisher": {
        "@type": "Organization",
        "name": "JSCON-简时空",
        "logo": "https://boycgit.github.io/content/images/2018/08/logoicon.png"
    },
    "author": {
        "@type": "Person",
        "name": "boycgit",
        "image": {
            "@type": "ImageObject",
            "url": "//www.gravatar.com/avatar/8b26b02c66a0e37c2183431d58502c25?s=250&d=mm&r=x",
            "width": 250,
            "height": 250
        },
        "url": "https://boycgit.github.io/author/boycgit/",
        "sameAs": []
    },
    "headline": "ES7 decorator 装饰者模式",
    "url": "https://boycgit.github.io/es7-decorator/",
    "datePublished": "2017-02-03T09:36:00.000Z",
    "dateModified": "2018-08-17T07:57:12.000Z",
    "image": {
        "@type": "ImageObject",
        "url": "https://casper.ghost.org/v1.0.0/images/design.jpg",
        "width": 1400,
        "height": 1050
    },
    "keywords": "javascript, 教程",
    "description": "装饰者模式 1、装饰模式 设计模式大家都有了解，网上有很多系列教程，比如 JS设计模式等等。  这里只分享 装饰者模式 以及在 如何使用 ES7 的 decorator 概念  1.1、装饰模式 v.s. 适配器模式 装饰模式和适配器模式都是“包装模式”(Wrapper Pattern)，它们都是通过封装其他对象达到设计的目的的，但是它们的形态有很大区别。  适配器模式我们使用的场景比较多，比如连接不同数据库的情况，你需要包装现有的模块接口，从而使之适配数据库 —— 好比你手机使用转接口来适配插座那样；  装饰模式不一样，仅仅包装现有的模块，使之 “更加华丽” ，并不会影响原有接口的功能 —— 好比你给手机添加一个外壳罢了，并不影响手机原有的通话、充电等功能；    更多区别参见：设计模式——装饰模式（Decorator）  1.2、装饰模式场景 —— 面向AOP编程 装饰模式经典的应用是AOP编程，比如“",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://boycgit.github.io/"
    }
}
    </script>

    <script src="../public/ghost-sdk.js?v=11f1923694"></script>
<script>
ghost.init({
	clientId: "ghost-frontend",
	clientSecret: "7c2ea2eb9409"
});
</script>
    <meta name="generator" content="Ghost 2.31">
    <link rel="alternate" type="application/rss+xml" title="JSCON-简时空" href="https://boycgit.github.io/rss/">
    <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-69473481-3"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-69473481-3');
</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-beta/dist/katex.min.css" integrity="sha384-9tPv11A+glH/on/wEu99NVwDPwkMQESOocs/ZGXPoIiLE8MU/qkqUcZ3zzL+6DuH" crossorigin="anonymous">
<style>

/* 结束 */

  .end-block-wrap{
        color:#338daf;
        text-align: center;
    }

    .end-block-wrap img{
        border: none;
        max-width: 100%;
        margin: 0px auto; display: inline-block;
    }

    .end-block-wrap img.main{
        width: 30px;
    }


/* 参考文档 */
.ref-wrap .line-text{
    display: flex;justify-content:center;align-items:flex-end;
}

.ref-wrap .line-text::before, .ref-wrap .line-text::after{
    content: '';
    display: inline-block;
    width: 25%; border-bottom: 1px dashed rgb(51, 51, 51); box-sizing: border-box;
}

.ref-wrap .text.main{
    font-size: 14px; 
    color: rgb(0, 0, 0); 
    letter-spacing: 1.5px; 
    padding: 0px 10px; 
    font-weight: bold; 
    margin-bottom: -5px; 
    box-sizing: border-box;
}

.ref-wrap  .text.second{
    font-size: 16px; 
    color: rgb(0, 0, 0); 
    letter-spacing: 1.5px; 
    padding: 10px; 
    text-align: center; 
    box-sizing: border-box;
}
/* 求关注 */
.qr-wrap{
    margin-right: auto; 
    margin-left: auto; 
    width: 360px; 
    border: none rgb(255, 129, 36); 
    background: url(https://mpt.135editor.com/mmbiz_gif/ziadDDQxbCJFA2XMwm7VE1RTcS94u8LqVWSjIasMfzY8aG5HolkBhHhwEp0eUpPCEzPYqXYicbRNtROJibbM9P55g/0?wx_fmt=gif) right 0px no-repeat; 
    background-size: contain; 
    box-sizing: border-box;
}

.qr-image{
    padding: 10px 3px; 
    width: 150px; 
    display: inline-block; 
    box-sizing: border-box;
}

.qr-image img{
    width: 150px;
}


</style>

</head>
<body class="post-template tag-javascript tag-jiao-cheng">

    <div class="site-wrapper">

        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.3.3/dist/gitalk.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightbox2@2.10.0/dist/css/lightbox.min.css">



<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
                <a class="site-nav-logo" href="https://boycgit.github.io"><img src="../content/images/2018/08/logoicon.png" alt="JSCON-简时空"></a>
            <ul class="nav" role="menu">
    <li class="nav-shou-ye" role="menuitem"><a href="https://boycgit.github.io/">首页</a></li>
    <li class="nav-guan-yu" role="menuitem"><a href="https://boycgit.github.io/about-me/">关于</a></li>
</ul>

    </div>
    <div class="site-nav-right">
        <div class="social-links">
        </div>
            <a class="rss-button" href="https://feedly.com/i/subscription/feed/https://boycgit.github.io/rss/" target="_blank" rel="noopener"><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24"><circle cx="6.18" cy="17.82" r="2.18"></circle><path d="M4 4.44v2.83c7.03 0 12.73 5.7 12.73 12.73h2.83c0-8.59-6.97-15.56-15.56-15.56zm0 5.66v2.83c3.9 0 7.07 3.17 7.07 7.07h2.83c0-5.47-4.43-9.9-9.9-9.9z"></path></svg>
</a>
    </div>
</nav>
    </div>
</header>


<main id="site-main" class="site-main outer">
    <div class="inner">

        <article class="post-full post tag-javascript tag-jiao-cheng ">

            <header class="post-full-header">
                <section class="post-full-meta">
                    <time class="post-full-meta-date" datetime="2017-02-03">3 February 2017</time>
                        <span class="date-divider">/</span> <a href="../tag/javascript/">javascript</a>
                </section>
                <h1 class="post-full-title">ES7 decorator 装饰者模式</h1>
            </header>

            <figure class="post-full-image" style="background-image: url(https://casper.ghost.org/v1.0.0/images/design.jpg)">
            </figure>

            <section class="post-full-content">
                <div class="post-content">
                    <h1 id="">装饰者模式</h1>
<h2 id="1">1、装饰模式</h2>
<p>设计模式大家都有了解，网上有很多系列教程，比如 <a href="http://www.alloyteam.com/2012/10/common-javascript-design-patterns/">JS设计模式</a>等等。</p>
<p>这里只分享 <strong>装饰者模式</strong> 以及在 如何使用 ES7 的 <code>decorator</code> 概念</p>
<h3 id="11vs">1.1、装饰模式 v.s. 适配器模式</h3>
<p>装饰模式和适配器模式都是“<strong>包装模式</strong>”(Wrapper Pattern)，它们都是通过封装其他对象达到设计的目的的，但是它们的形态有很大区别。</p>
<ul>
<li>
<p><strong>适配器模式</strong>我们使用的场景比较多，比如连接不同数据库的情况，你需要包装现有的模块接口，从而使之适配数据库 —— 好比你手机使用转接口来适配插座那样；</p>
</li>
<li>
<p><strong>装饰模式</strong>不一样，仅仅包装现有的模块，使之 “更加华丽” ，并不会影响原有接口的功能 —— 好比你给手机添加一个外壳罢了，并不影响手机原有的通话、充电等功能；<br>
<img src="https://lh3.googleusercontent.com/-jwQs4Joq724/VijLrTm7JvI/AAAAAAAACb0/tQJ8csD0VUY/s640/2015.10.16%252520-%252520%2525E7%25258E%252584%2525E5%252586%25259C-js%252520decorate%2525E5%252588%252586%2525E4%2525BA%2525AB.003.jpeg" alt="更加华丽"></p>
</li>
</ul>
<p>更多区别参见：<a href="http://blog.csdn.net/zhshulin/article/details/38665187">设计模式——装饰模式（Decorator）</a></p>
<h3 id="12aop">1.2、装饰模式场景 —— 面向AOP编程</h3>
<p>装饰模式经典的应用是AOP编程，比如“日志系统”，日志系统的作用是记录系统的行为操作，它在不影响原有系统的功能的基础上增加记录环节 —— 好比你佩戴了一个智能手环，并不影响你日常的作息起居，但你现在却有了自己每天的行为记录。</p>
<p>更加抽象的理解，可以理解为给数据流做一层<code>filter</code>，因此AOP 的典型应用包括 安全检查、缓存、调试、持久化等等。可参考<a href="http://haidaoqi3630.iteye.com/blog/2172845">Spring aop 原理及各种应用场景</a>。<br>
<img src="https://lh3.googleusercontent.com/-0i4zF6wypp8/VijLuNykK3I/AAAAAAAACcE/4HkNejYpsR4/s640/2015.10.16%252520-%252520%2525E7%25258E%252584%2525E5%252586%25259C-js%252520decorate%2525E5%252588%252586%2525E4%2525BA%2525AB.004.jpeg" alt="aop"></p>
<h2 id="2es7decorator">2、使用ES7的decorator</h2>
<p>ES7中增加了一个 <code>decorator</code> 属性，它借鉴自Python，请参考文章<a href="http://www.liuhaihua.cn/archives/115548.html">Decorators in ES7</a>。</p>
<p>下面我们以 <strong>钢铁侠</strong> 为例讲解如何使用 ES7的decorator。</p>
<p>以钢铁侠为例，钢铁侠本质是一个人，只是“装饰”了很多武器方才变得那么NB，不过再怎么装饰他还是一个人。<br>
<img src="https://lh3.googleusercontent.com/-aOKo-tuz0U8/VijLtPLKLMI/AAAAAAAACb8/rJqK_DXmUaI/s640/2015.10.16%252520-%252520%2525E7%25258E%252584%2525E5%252586%25259C-js%252520decorate%2525E5%252588%252586%2525E4%2525BA%2525AB.002.jpeg" alt="钢铁侠"></p>
<p>我们的示例场景是这样的</p>
<ul>
<li>首先创建一个普通的<code>Man</code>类，它的抵御值2，攻击力为3，血量为3；</li>
<li>然后我们让其带上钢铁侠的盔甲，这样他的抵御力增加100，变成102；</li>
<li>让其带上光束手套，攻击力增加50，变成53；</li>
<li>最后让他增加“飞行”能力</li>
</ul>
<p><img src="https://lh3.googleusercontent.com/-cEVYRahcaEs/VijLvNDgrDI/AAAAAAAACcQ/k0QWgSLOTFI/s640/2015.10.16%252520-%252520%2525E7%25258E%252584%2525E5%252586%25259C-js%252520decorate%2525E5%252588%252586%2525E4%2525BA%2525AB.005.jpeg" alt="ironman"></p>
<h3 id="21demo1">2.1、【Demo 1】对方法的装饰：装备盔甲</h3>
<p><strong>创建Man类</strong>：</p>
<pre><code class="language-js">class Man{
  constructor(def = 2,atk = 3,hp = 3){
    this.init(def,atk,hp);
  }

  init(def,atk,hp){
    this.def = def; // 防御值
    this.atk = atk;  // 攻击力
    this.hp = hp;  // 血量
  }
  toString(){
    return `防御力:${this.def},攻击力:${this.atk},血量:${this.hp}`;
  }
}

var tony = new Man();

console.log(`当前状态 ===&gt; ${tony}`); 

// 输出：当前状态 ===&gt; 防御力:2,攻击力:3,血量:3
</code></pre>
<blockquote>
<p>代码直接放在 <a href="http://babeljs.io/repl/">http://babeljs.io/repl/</a> 中运行查看结果，记得勾选<code>Experimental</code>选项和<code>Evaluate</code>选项</p>
</blockquote>
<p>创建 <strong>decorateArmour</strong> 方法，为钢铁侠装配盔甲——注意 <code>decorateArmour</code> 是装饰在方法<code>init</code>上的。</p>
<pre><code class="language-js">function decorateArmour(target, key, descriptor) {
  const method = descriptor.value;
  let moreDef = 100;
  let ret;
  descriptor.value = (...args)=&gt;{
    args[0] += moreDef;
    ret = method.apply(target, args);
    return ret;
  }
  return descriptor;
}

class Man{
  constructor(def = 2,atk = 3,hp = 3){
    this.init(def,atk,hp);
  }

  @decorateArmour
  init(def,atk,hp){
    this.def = def; // 防御值
    this.atk = atk;  // 攻击力
    this.hp = hp;  // 血量
  }
  toString(){
    return `防御力:${this.def},攻击力:${this.atk},血量:${this.hp}`;
  }
}

var tony = new Man();

console.log(`当前状态 ===&gt; ${tony}`);
// 输出：当前状态 ===&gt; 防御力:102,攻击力:3,血量:3
</code></pre>
<p>我们先看输出结果，防御力的确增加了 <strong>100</strong>，看来盔甲起作用了。</p>
<p>初学者这里会有两个疑问：</p>
<ul>
<li>
<ol>
<li><code>decorateArmour</code>方法的参数为啥是这三个？可以更换么？</li>
</ol>
</li>
<li>
<ol start="2">
<li><code>decorateArmour</code>方法为什么返回的是<code>descriptor</code></li>
</ol>
</li>
</ul>
<p>这里给出个人的解答作为参考：</p>
<ol>
<li><strong>Decorators</strong> 的本质是利用了ES5的 <strong>Object.defineProperty</strong> 属性，这三个参数其实是和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">Object.defineProperty</a>参数一致的，因此不能更改，详细分析请见 <a href="http://greengerong.com/blog/2015/09/24/es7-javascript-decorators/">细说ES7 JavaScript Decorators</a></li>
<li>可以看看 <strong>bable转换后</strong> 的代码，其中有一句是<code>descriptor = decorator(target, key, descriptor) || descriptor;</code>，点到为止，这里不详细展开了，可自行看看这行代码的上下文（参考文献中也涉及到这句代码的解释）。</li>
</ol>
<h3 id="22demo2">2.2、【Demo 2】装饰器叠加：增加光束手套</h3>
<p>在上面的示例中，我们成功为 普通人 增加 “盔甲” 这个装饰；现在我想再给他增加 “光束手套”，希望额外增加 <strong>50</strong> 点防御值。</p>
<p><strong>Step 1</strong>：拷贝一份<code>decorateArmour</code>方法，改名为<code>decorateLight</code>，同时修改防御值的属性：</p>
<pre><code class="language-js">function decorateLight(target, key, descriptor) {
  const method = descriptor.value;
  let moreAtk = 50;
  let ret;
  descriptor.value = (...args)=&gt;{
    args[1] += moreAtk;
    ret = method.apply(target, args);
    return ret;
  }
  return descriptor;
}
</code></pre>
<p><strong>Step 2</strong>：直接在<code>init</code>方法上添加装饰语法：</p>
<pre><code class="language-js">....
  @decorateArmour
  @decorateLight
  init(def,atk,hp){
    this.def = def; // 防御值
    this.atk = atk;  // 攻击力
    this.hp = hp;  // 血量
  }
 ...
</code></pre>
<p>最后的代码如下：</p>
<pre><code class="language-js">...
function decorateLight(target, key, descriptor) {
  const method = descriptor.value;
  let moreAtk = 50;
  let ret;
  descriptor.value = (...args)=&gt;{
    args[1] += moreAtk;
    ret = method.apply(target, args);
    return ret;
  }
  return descriptor;
}

class Man{
  constructor(def = 2,atk = 3,hp = 3){
    this.init(def,atk,hp);
  }

  @decorateArmour
  @decorateLight
  init(def,atk,hp){
    this.def = def; // 防御值
    this.atk = atk;  // 攻击力
    this.hp = hp;  // 血量
  }
...
}
var tony = new Man();
console.log(`当前状态 ===&gt; ${tony}`);
//输出：当前状态 ===&gt; 防御力:102,攻击力:53,血量:3
</code></pre>
<p>在这里你就能看出装饰模式的优势了，它可以对某个方法进行叠加使用，对原类的侵入性非常小，只是增加一行<code>@decorateLight</code>而已，可以方便地增删；（同时还可以复用）</p>
<h3 id="23demo3">2.3、【Demo 3】对类的装饰：增加飞行能力</h3>
<p>按文章 <a href="http://blog.csdn.net/zhshulin/article/details/38665187">装饰模式</a>所言，装饰模式有两种：<strong>纯粹的装饰模式</strong> 和 <strong>半透明的装饰模式</strong>。</p>
<p>上述的两个demo中所使用的应该是 <strong>纯粹的装饰模式</strong>，它并不增加对原有类的接口；下面要讲demo是给普通人增加“飞行”能力，相当于给类新增一个方法，属于 <strong>半透明的装饰模式</strong>，有点儿像适配器模式的样子。</p>
<p><strong>Step 1</strong>：增加一个方法：</p>
<pre><code class="language-js">function addFly(canFly){
  return function(target){
    target.canFly = canFly;
    let extra = canFly ? '(技能加成:飞行能力)' : '';
    let method = target.prototype.toString;
    target.prototype.toString = (...args)=&gt;{
      return method.apply(target.prototype,args) + extra;
    }
    return target;
  }
}
</code></pre>
<p><strong>Step 2</strong>：这个方法将直接去装饰类：</p>
<pre><code class="language-js">
...

// 3
function addFly(canFly){
  return function(target){
    target.canFly = canFly;
    let extra = canFly ? '(技能加成:飞行能力)' : '';
    let method = target.prototype.toString;
    target.prototype.toString = (...args)=&gt;{
      return method.apply(target.prototype,args) + extra;
    }
    return target;
  }
}

@addFly(true)
class Man{
  constructor(def = 2,atk = 3,hp = 3){
    this.init(def,atk,hp);
  }

  @decorateArmour
  @decorateLight
  init(def,atk,hp){
    this.def = def; // 防御值
    this.atk = atk;  // 攻击力
    this.hp = hp;  // 血量
  }
  ...
}
...

console.log(`当前状态 ===&gt; ${tony}`);
// 输出：当前状态 ===&gt; 防御力:102,攻击力:53,血量:3(技能加成:飞行能力)
</code></pre>
<p>作用在方法上的 <code>decorator</code> 接收的第一个参数（<strong>target</strong> ）是类的 <code>prototype</code>；如果把一个 <code>decorator</code> 作用到类上，则它的第一个参数 target 是 <strong>类本身</strong>。（参考 <a href="http://www.liuhaihua.cn/archives/115548.html">Decorators in ES7</a> ）</p>
<h2 id="3js">3、使用原生JS实现装饰器模式</h2>
<p>关于如何用现有标准的原生JS实现的装饰模式，可参考译文<br>
<a href="http://www.codingserf.com/index.php/2015/05/javascript-design-patterns-decorator/">JavaScript设计模式：装饰者模式</a>，这是一篇值得一读的文章，深入浅出。</p>
<p>这里用ES5重写一下上面的 Demo 1的场景，简略说一下关键点：</p>
<ol>
<li>Man是具体的类，<strong>Decorator</strong> 是针对 <strong>Man</strong>  的装饰器基类</li>
<li>具体的装饰类 <strong>DecorateArmour</strong> 典型地使用 <strong>prototype 继承方式</strong> 继承自 <strong>Decorator</strong> 基类；</li>
<li>基于 <strong>IOC（控制反转）思想</strong> ，<strong>Decorator</strong> 是接受 <strong>Man</strong> 类，而不是自己创建  <strong>Man</strong>  类；</li>
</ol>
<p>最后代码是：</p>
<pre><code class="language-js">// 首先我们要创建一个基类
function Man(){

  this.def = 2;
  this.atk = 3; 
  this.hp = 3;
}

// 装饰者也需要实现这些方法，遵守Man的接口
Man.prototype={
  toString:function(){
    return `防御力:${this.def},攻击力:${this.atk},血量:${this.hp}`;
  }
}
// 创建装饰器，接收Man对象作为参数。
var Decorator = function(man){
  this.man = man;
}

// 装饰者要实现这些相同的方法
Decorator.prototype.toString = function(){
    return this.man.toString();
}

// 继承自装饰器对象
// 创建具体的装饰器，也是接收Man作对参数
var DecorateArmour = function(man){

  var moreDef = 100;
  man.def += moreDef;
  Decorator.call(this,man);

}
DecorateArmour.prototype = new Decorator();

// 接下来我们要为每一个功能创建一个装饰者对象，重写父级方法，添加我们想要的功能。
DecorateArmour.prototype.toString = function(){
  return this.man.toString();
} 

// 注意这里的调用方式
// 构造器相当于“过滤器”，面向切面的
var tony = new Man();
tony = new DecorateArmour(tony);
console.log(`当前状态 ===&gt; ${tony}`);
// 输出：当前状态 ===&gt; 防御力:102,攻击力:3,血量:3
</code></pre>
<h2 id="4logger">4、经典实现：Logger</h2>
<p>AOP的经典应用就是 <strong>日志系统</strong> 了，那么我们也用ES7的语法给钢铁侠打造一个日志系统吧。</p>
<p><img src="https://lh3.googleusercontent.com/-FFBrw6zw4JY/VijLzWBVrAI/AAAAAAAACcs/O4qgscc8EmY/s640/2015.10.16%252520-%252520%2525E7%25258E%252584%2525E5%252586%25259C-js%252520decorate%2525E5%252588%252586%2525E4%2525BA%2525AB.009.jpeg" alt="logger"></p>
<p>下面是最终的代码：</p>
<pre><code class="language-js">/**
 * Created by jscon on 15/10/16.
 */
let log = (type) =&gt; {

  return (target, name, descriptor) =&gt; {
    const method = descriptor.value;
    descriptor.value =  (...args) =&gt; {
      console.info(`(${type}) 正在执行: ${name}(${args}) = ?`);
      let ret;
      try {
        ret = method.apply(target, args);
        console.info(`(${type}) 成功 : ${name}(${args}) =&gt; ${ret}`);
      } catch (error) {
        console.error(`(${type}) 失败: ${name}(${args}) =&gt; ${error}`);
      }
      return ret;
    }
  }
}
class IronMan {
  @log('IronMan 自检阶段')
  check(){
    return '检查完毕';
  }
  @log('IronMan 攻击阶段')
  attack(){
    return '击倒敌人';
  }
  @log('IronMan 机体报错')
  error(){
    throw 'Something is wrong!';
  }
}

var tony = new IronMan();
tony.check();
tony.attack();
tony.error();

// 输出：
// (IronMan 自检阶段) 正在执行: check() = ?
// (IronMan 自检阶段) 成功 : check() =&gt; 检查完毕
// (IronMan 攻击阶段) 正在执行: attack() = ?
// (IronMan 攻击阶段) 成功 : attack() =&gt; 击倒敌人
// (IronMan 机体报错) 正在执行: error() = ?
// (IronMan 机体报错) 失败: error() =&gt; Something is wrong!
</code></pre>
<p><strong>Logger</strong>方法的关键在于：</p>
<ul>
<li>首先使用 <code>const method = descriptor.value;</code> 将原有方法提取出来，保障原有方法的纯净；</li>
<li>在 <strong>try..catch</strong> 语句是 调用 <code>ret = method.apply(target, args);</code>在调用之前之后分别进行日志汇报；</li>
<li>最后返回 <code>return ret;</code> 原始的调用结果</li>
</ul>
<p>相信这套思路会给后续我们实现AOP模式提供良好的借鉴。</p>
<h2 id="5">5、扩展</h2>
<h2 id="51">5.1、基于工厂模式</h2>
<p>当你想要一个有3种功能的钢铁侠，就得用 <strong>new操作符</strong> 创建4个对象。这么做单调乏味又烦人，所以我们打算只调用一个方法就能创建出一部拥有所有功能的钢铁侠。</p>
<p>这就需要 <strong>工厂模式</strong> 了，工厂模式的官方定义是：在子类中对一个类的成员对象进行实例化。比如定义 <strong>decorateIronMan（person,feature）</strong> 方法，里面接受一个 <strong>Person</strong> 对象（而不是自己初始化）,相当于流水线生产了。</p>
<p><img src="https://lh3.googleusercontent.com/-IrLb0zptFpg/VijL1SL-raI/AAAAAAAACc8/-2fi_D61Wa0/s640/2015.10.16%252520-%252520%2525E7%25258E%252584%2525E5%252586%25259C-js%252520decorate%2525E5%252588%252586%2525E4%2525BA%2525AB.008.jpeg" alt="factory"></p>
<p>如何 <strong>结合装饰模式和工厂模式</strong> 提高代码效能，这篇优秀的译文 <a href="http://www.codingserf.com/index.php/2015/05/javascript-design-patterns-factory-part-1/">JavaScript设计模式：工厂模式</a> 给出了详细的方法，这里不再赘述，强烈推荐阅读此文。</p>
<h2 id="52purerenderdecorator">5.2、pure-render-decorator</h2>
<p>React 做性能优化时有一个避免重复渲染的大招，就是使用 <code>shouldComponentUpdate()</code>，用于避免不必要的重新渲染，借用<code>Immutable</code>可以极大提高性能；可以直接使用官方的<code>React.addons.PureRenderMixin</code>，或者使用<a href="https://www.npmjs.com/package/pure-render-decorator">pure-render-decorator</a>，其就是使用了ES7的<code>Decorator</code>：</p>
<pre><code class="language-js">import {Component} from 'react';
import pureRender from 'pure-render-decorator';
 
@pureRender
class Test extends Component {
  render() {
    return &lt;div&gt;&lt;/div&gt;;
  }
}
</code></pre>
<p>等效于：</p>
<pre><code class="language-js">var React = require('react');
var PureRenderMixin = require('react-addons-pure-render-mixin');
 
var Test = React.createClass({
  mixins: [
    PureRenderMixin
  ],
 
  render: function() {
    return &lt;div&gt;&lt;/div&gt;;
  }
});
</code></pre>
<h2 id="6">6、现在就想用？</h2>
<p><code>decorator</code> 目前还只是一个提议，但是感谢 Babel ，我们现在就可以体验它了。首先，安装 <strong>babel</strong>：</p>
<pre><code class="language-js">npm install babel -g
</code></pre>
<p>然后，开启 <strong>decorator</strong>：</p>
<pre><code class="language-js">babel --optional es7.decorators foo.js &gt; foo.es5.js
</code></pre>
<p>babel 也提供了一个<a href="http://babeljs.io/repl/">在线的 REPL</a> ，勾选  <strong>experimental 选项</strong>，就可以了。</p>
<h3 id="webstormbabel">在webstorm中设置babel</h3>
<p><strong>Step 1</strong>：首先全局安装<code>babel</code>组件模块</p>
<pre><code class="language-js">npm install -g babel
</code></pre>
<p><strong>Step 2</strong>：设置scope （这一步可以省略）</p>
<p><img src="https://lh3.googleusercontent.com/-Nf4nWOn8xq4/VijgN2MO_iI/AAAAAAAACeI/yVN_AMwHhvE/s640/2015-06-11-webstorm-add-scope-1024x630.png" alt="设置"></p>
<p><strong>命名scope：</strong></p>
<p><img src="https://lh3.googleusercontent.com/-Z_9myWbGlaA/VijgOAtk6SI/AAAAAAAACeI/sBk6YYmAlfo/s640/ws-2.png" alt="命名scope"></p>
<p><strong>将文件添加到当前scope</strong>：<br>
<img src="https://lh3.googleusercontent.com/-9ELihywPAx0/VijgOERy2dI/AAAAAAAACeI/Y9W6iBIel5Q/s640/ws-3.png" alt="add"></p>
<p><strong>Step 3</strong>：设置ES版本</p>
<p><img src="https://lh3.googleusercontent.com/-wMyJjsatkao/VijgOu5XI-I/AAAAAAAACeI/MQzBDiTwOLE/s640/.png" alt="set"></p>
<p><strong>Step 4</strong>：添加watcher</p>
<p><img src="https://lh3.googleusercontent.com/-lCMQXwTdCXo/VijgO1lQf3I/AAAAAAAACeI/LDw0AvyeWfQ/s640/ws-5.png" alt="watcher"></p>
<blockquote>
<p>arguments内可以填写：<code>$FilePathRelativeToProjectRoot$ --stage --out-file $FileNameWithoutExtension$-es5.js $FilePath$</code></p>
</blockquote>
<p>.</p>
<blockquote>
<p>如果需要source-map，需要添加<code>--source-map</code>选项，同时在<code>Output paths to refresh</code>中填写 <code>$FileNameWithoutExtension$-es5.js:$FileNameWithoutExtension$-es5.js.map</code></p>
</blockquote>
<p>更多设置参考<a href="http://babeljs.io/docs/usage/cli/">babel cli</a></p>
<h2 id="7">7、总结</h2>
<p>虽然它是ES7的特性，但在Babel大势流行的今天，我们可以利用Babel来使用它。我们可以利用Babel命令行工具，或者grunt、gulp、webpack的babel插件来使用Decorators。</p>
<p>上述的代码都可以直接放在 <a href="http://babeljs.io/repl/">http://babeljs.io/repl/</a> 中运行查看结果；</p>
<p>关于ES7 Decorators的更有意思的玩法，你可以参见牛人实现的常用的 <a href="https://github.com/jayphelps/core-decorators.js">Decorators：core-decorators</a>。以及raganwald的 <a href="http://raganwald.com/2015/06/26/decorators-in-es7.html">如何用Decorators来实现Mixin</a>。</p>
<h3 id="">参考文献</h3>
<ul>
<li><a href="http://www.liuhaihua.cn/archives/115548.html">Decorators in ES7</a>：装饰者模式让你包装已有的方法，从而扩展已有函数。</li>
<li><a href="http://www.codingserf.com/index.php/2015/05/javascript-design-patterns-decorator/">JavaScript设计模式：装饰者模式</a>：严重推荐，这一系列让你比较透彻明白设计模式在JS中的应用。</li>
<li><a href="http://greengerong.com/blog/2015/09/23/es7-zhi-decorators-shi-xian-aopshi-li/">ES7之Decorators实现AOP示例</a>：如何实现一个简单的AOP。</li>
<li><a href="http://greengerong.com/blog/2015/09/24/es7-javascript-decorators/">细说ES7 JavaScript Decorators</a>：讲解ES7 Decorator的背后原理，就是使用了Object.defineProperty方法；</li>
<li><a href="http://mcculloughwebservices.com/2015/06/14/webstorm-babel-plugin/">How To Set Up the Babel Plugin in WebStorm</a>：图文并茂，教你如何设置babel.</li>
<li><a href="http://web.jobbole.com/82923/">Rest 参数和参数默认值</a>：ES6 为我们提供一种新的方式来创建可变参数的函数，Rest 参数和参数默认值</li>
<li><a href="https://medium.com/google-developers/exploring-es7-decorators-76ecb65fb841">Exploring ES2016 Decorators</a>：很完整的一个教程，里面涉及比较全面。</li>
<li><a href="http://cocktailjs.github.io/blog/traits-with-es7-decorators.html">Traits with ES7 Decorators</a>：相当于是介绍 <code>traits-decorator</code> 模块；</li>
</ul>

                </div>
            </section>
            <p style="text-align: center">下面的是我的公众号二维码图片，欢迎关注，及时获取最新技术文章。</p>
            <section style="text-align: center"><img src="https://raw.githubusercontent.com/boycgit/web-image/master/blogqrcode2.jpg"></section>
            <script src="https://cdn.jsdelivr.net/npm/katex@0.10.0-beta/dist/katex.min.js" integrity="sha384-U8Vrjwb8fuHMt6ewaCy8uqeUXv4oitYACKdB0VziCerzt011iQ/0TqlSlv8MReCm" crossorigin="anonymous"></script>
            <script src="https://cdn.jsdelivr.net/npm/katex@0.10.0-beta/dist/contrib/auto-render.min.js" integrity="sha384-aGfk5kvhIq5x1x5YdvCp4upKZYnA8ckafviDpmWEKp4afOZEqOli7gqSnh8I6enH" crossorigin="anonymous"></script>


            <section id="gitalk-component-wrap"></section>

            <footer class="post-full-footer">


                    
<section class="author-card">
        <img class="author-profile-image" src="http://www.gravatar.com/avatar/8b26b02c66a0e37c2183431d58502c25?s=250&amp;d=mm&amp;r=x" alt="boycgit">
    <section class="author-card-content">
        <h4 class="author-card-name"><a href="../author/boycgit/">boycgit</a></h4>
            <p>阅读此作者的<a href="../author/boycgit/">更多文章</a>.</p>
    </section>
</section>
<div class="post-full-footer-right">
    <a class="author-card-button" href="../author/boycgit/">阅读更多</a>
</div>


            </footer>


        </article>

    </div>
</main>

<aside class="read-next outer">
    <div class="inner">
        <div class="read-next-feed">
                <article class="read-next-card" style="background-image: url(https://casper.ghost.org/v1.0.0/images/blog-cover.jpg)">
                    <header class="read-next-card-header">
                        <small class="read-next-card-header-sitetitle">— JSCON-简时空 —</small>
                        <h3 class="read-next-card-header-title"><a href="../tag/javascript/">javascript</a></h3>
                    </header>
                    <div class="read-next-divider"><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24"><path d="M13 14.5s2 3 5 3 5.5-2.463 5.5-5.5S21 6.5 18 6.5c-5 0-7 11-12 11C2.962 17.5.5 15.037.5 12S3 6.5 6 6.5s4.5 3.5 4.5 3.5"></path></svg>
</div>
                    <div class="read-next-card-content">
                        <ul>
                            <li><a href="../debugging-with-ts-jest/">在 ts + Jest 单元测试中 debugging</a></li>
                            <li><a href="../typescript-advance-cheatsheet/">速查手册 - TypeScript 高级类型 cheat sheet</a></li>
                            <li><a href="../react-hooks-capture-value/">理解 React Hooks 的 Capture Value 特性</a></li>
                        </ul>
                    </div>
                    <footer class="read-next-card-footer">
                        <a href="../tag/javascript/">查看所有13篇文章 →</a>
                    </footer>
                </article>

                <article class="post-card post tag-javascript tag-mobx tag-yuan-ma-fen-xi tag-yuan-ma">
        <a class="post-card-image-link" href="../mobx-source-autorun/">
            <div class="post-card-image" style="background-image: url(../content/images/2018/08/111.jpg)"></div>
        </a>
    <div class="post-card-content">
        <a class="post-card-content-link" href="../mobx-source-autorun/">
            <header class="post-card-header">
                    <span class="post-card-tags">javascript</span>
                <h2 class="post-card-title">【用故事解读 MobX源码（一）】 autorun</h2>
            </header>
            <section class="post-card-excerpt">
                <p>网上已有很多关于 MobX 源码解读的文章，但大多阅读成本甚高。本人在找文章时对此深有体会，故将以系列故事的方式展现源码逻辑，尽可能以易懂的方式讲解 MobX 源码；本文分析 autorun 源码的执行逻辑</p>
            </section>
        </a>
        <footer class="post-card-meta">

            <ul class="author-list">
                <li class="author-list-item">

                    <div class="author-name-tooltip">
                        boycgit
                    </div>

                        <a href="../author/boycgit/" class="static-avatar"><img class="author-profile-image" src="http://www.gravatar.com/avatar/8b26b02c66a0e37c2183431d58502c25?s=250&amp;d=mm&amp;r=x" alt="boycgit"></a>
                </li>
            </ul>

            <span class="reading-time">阅读耗时约 30 分钟</span>

        </footer>
    </div>
</article>

                <article class="post-card post tag-webpack tag-yuan-ma-fen-xi tag-yuan-ma">
        <a class="post-card-image-link" href="../webpack-how-to-read/">
            <div class="post-card-image" style="background-image: url(https://images.unsplash.com/photo-1532622785990-d2c36a76f5a6?ixlib=rb-1.2.1&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=1080&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ)"></div>
        </a>
    <div class="post-card-content">
        <a class="post-card-content-link" href="../webpack-how-to-read/">
            <header class="post-card-header">
                    <span class="post-card-tags">Webpack</span>
                <h2 class="post-card-title">Webpack 源码（二）—— 如何阅读源码</h2>
            </header>
            <section class="post-card-excerpt">
                <p>本文以一个公司（Company）来类比，方便去理解  Compiler 、Compilation 、Module 等关键对象，阅读源码的过程其实可以认为是了解对象的方法和属性的过程；本文不对 Webpack 流程再做重复的描述，而是从另外一个角度补充分析 Webpack 源码。</p>
            </section>
        </a>
        <footer class="post-card-meta">

            <ul class="author-list">
                <li class="author-list-item">

                    <div class="author-name-tooltip">
                        boycgit
                    </div>

                        <a href="../author/boycgit/" class="static-avatar"><img class="author-profile-image" src="http://www.gravatar.com/avatar/8b26b02c66a0e37c2183431d58502c25?s=250&amp;d=mm&amp;r=x" alt="boycgit"></a>
                </li>
            </ul>

            <span class="reading-time">阅读耗时约 3 分钟</span>

        </footer>
    </div>
</article>

        </div>
    </div>
</aside>

<div class="floating-header">
    <div class="floating-header-logo">
        <a href="https://boycgit.github.io">
                <img src="../content/images/2018/08/logo.png" alt="JSCON-简时空 icon">
            <span>JSCON-简时空</span>
        </a>
    </div>
    <span class="floating-header-divider">—</span>
    <div class="floating-header-title">ES7 decorator 装饰者模式</div>
    <div class="floating-header-share">
        <div class="floating-header-share-label">分享 <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24">
    <path d="M7.5 15.5V4a1.5 1.5 0 1 1 3 0v4.5h2a1 1 0 0 1 1 1h2a1 1 0 0 1 1 1H18a1.5 1.5 0 0 1 1.5 1.5v3.099c0 .929-.13 1.854-.385 2.748L17.5 23.5h-9c-1.5-2-5.417-8.673-5.417-8.673a1.2 1.2 0 0 1 1.76-1.605L7.5 15.5zm6-6v2m-3-3.5v3.5m6-1v2"></path>
</svg>
</div>
        <a class="floating-header-share-weibo" href="http://service.weibo.com/share/share.php?title=%E7%9C%8B%E5%88%B0%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E3%80%8AES7%20decorator%20%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E3%80%8B%EF%BC%8C%E5%BE%88%E7%B2%BE%E5%BD%A9%EF%BC%8C%E6%83%B3%E5%88%86%E4%BA%AB%E7%BB%99%E5%A4%A7%E4%BC%99%E5%84%BF&amp;url=https://boycgit.github.io/es7-decorator/" onclick="window.open(this.href, 'share-weibo', 'width=550,height=235');return false;">
            <?xml version="1.0" standalone="no"?><svg t="1534600204727" class="icon" style="" viewbox="0 0 1026 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4202" xmlns:xlink="http://www.w3.org/1999/xlink" width="16.03125" height="16"><defs><style type="text/css"></style></defs><path d="M1012.49 451.553v0.159c-6.697 20.66-28.861 31.99-49.449 25.288a39.352 39.352 0 0 1-25.287-49.582l-0.067-0.031c20.536-63.6 7.516-136.156-40.315-189.363-47.892-53.212-118.502-73.554-183.731-59.659-21.222 4.537-42.133-9.047-46.638-30.3-4.506-21.253 9.021-42.194 30.239-46.73 91.709-19.563 191.114 8.98 258.467 83.881 67.36 74.839 85.515 176.85 56.781 266.337z" fill="#ffffff" p-id="4203"></path><path d="M740.429 304.348v-0.03c-18.217 3.973-36.178-7.732-40.06-26.01-3.947-18.31 7.763-36.373 25.98-40.254 44.692-9.548 93.143 4.322 125.885 40.781 32.866 36.496 41.631 86.17 27.607 129.772a33.833 33.833 0 0 1-42.562 21.847c-17.782-5.76-27.484-24.914-21.724-42.69h-0.062c6.887-21.346 2.565-45.635-13.46-63.473-16.026-17.818-39.752-24.546-61.604-19.943z m30.05 192.184c-14.46-4.352-24.352-7.326-16.774-26.352 16.333-41.313 18.027-76.964 0.317-102.385-33.31-47.734-124.451-45.133-228.838-1.28 0-0.061-32.799 14.367-24.412-11.704 16.056-51.774 13.645-95.186-11.361-120.192-56.658-56.878-207.304 2.12-336.477 131.64C56.187 463.32 0 566.14 0 655.1 0 825.18 217.503 928.594 430.28 928.594c278.917 0 464.527-162.504 464.527-291.59 0-77.936-65.546-122.193-124.329-140.472zM430.842 867.62c-169.774 16.84-316.35-60.155-327.368-171.96-11.049-111.74 117.72-216.034 287.488-232.873 169.805-16.84 316.355 60.16 327.368 171.904 11.018 111.866-117.683 216.09-287.488 232.929z" fill="#ffffff" p-id="4204"></path><path d="M447.805 548.859c-80.783-21.09-172.119 19.287-207.206 90.65-35.743 72.862-1.188 153.681 80.44 180.1 84.578 27.357 184.233-14.525 218.88-93.148 34.181-76.81-8.478-155.94-92.114-177.602zM386.12 734.792c-16.43 26.29-51.584 37.806-78.065 25.661-26.107-11.889-33.833-42.44-17.403-68.045 16.215-25.538 50.207-36.869 76.498-25.856 26.604 11.392 35.087 41.687 18.97 68.24z" fill="#ffffff" p-id="4205"></path></svg>        </a>
        <a class="floating-header-share-weixin" href="https://cli.im/api/qrcode/code?text=https://boycgit.github.io/es7-decorator/&amp;mhid=txbODQq7nZkhMHcqI9xROqg" onclick="window.open(this.href, 'share-weixin','width=480,height=600');return false;">
            <?xml version="1.0" standalone="no"?><svg t="1534604253879" class="icon" style="" viewbox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5477" xmlns:xlink="http://www.w3.org/1999/xlink" width="16" height="16"><defs><style type="text/css"></style></defs><path d="M693.12 347.232c11.776 0 23.36 0.896 35.008 2.176C696.768 203.36 540.672 94.88 362.432 94.88 163.2 94.88 0 230.624 0 403.104c0 99.521 54.272 181.248 145.024 244.736L108.8 756.832l126.72-63.488c45.312 8.896 81.664 18.112 126.912 18.112 11.393 0 22.656-0.513 33.792-1.345-7.04-24.256-11.199-49.6-11.199-76.031C385.088 475.744 521.024 347.232 693.12 347.232zM498.304 248.992c27.393 0 45.376 17.984 45.376 45.248 0 27.136-17.983 45.312-45.376 45.312-27.071 0-54.336-18.176-54.336-45.312C443.968 266.912 471.168 248.992 498.304 248.992zM244.672 339.552c-27.2 0-54.592-18.176-54.592-45.312 0-27.264 27.392-45.248 54.592-45.248 27.2 0 45.248 17.92 45.248 45.248C289.92 321.376 271.872 339.552 244.672 339.552z" p-id="5478" fill="#ffffff"></path><path d="M1024 629.728c0-144.896-145.023-262.976-307.904-262.976-172.479 0-308.224 118.144-308.224 262.976 0 145.28 135.808 262.977 308.224 262.977 36.097 0 72.513-9.024 108.736-18.112l99.392 54.528-27.264-90.624C969.729 783.84 1024 711.456 1024 629.728zM616.128 584.352c-17.984 0-36.224-17.92-36.224-36.224 0-18.048 18.239-36.225 36.224-36.225 27.521 0 45.376 18.177 45.376 36.225C661.504 566.432 643.648 584.352 616.128 584.352zM815.488 584.352c-17.856 0-36.032-17.92-36.032-36.224 0-18.048 18.112-36.225 36.032-36.225 27.264 0 45.376 18.177 45.376 36.225C860.864 566.432 842.752 584.352 815.488 584.352z" p-id="5479" fill="#ffffff"></path></svg>        </a>
    </div>
    <progress id="reading-progress" class="progress" value="0">
        <div class="progress-container">
            <span class="progress-bar"></span>
        </div>
    </progress>
</div>



<script src="https://cdn.jsdelivr.net/npm/gitalk@1.3.3/dist/gitalk.min.js"></script>

<script>
    (function () {
        /**
         * Get Node
         * @param  {String|Element} el
         * @param  {Boolean} noCache
         * @return {Element}
         */
        var cacheNode = {};
        function getNode(el, noCache) {
            if (noCache === void 0) noCache = false;

            if (typeof el === 'string') {
                if (typeof window.Vue !== 'undefined') {
                    return find(el);
                }
                el = noCache ? find(el) : cacheNode[el] || (cacheNode[el] = find(el));
            }

            return el;
        }

        /**
         * Find element
         * @example
         * find('nav') => document.querySelector('nav')
         * find(nav, 'a') => nav.querySelector('a')
         */
        function find(el, node) {
            return node ? el.querySelector(node) : document.querySelector(el);
        }
        function create(node, tpl) {
            node = document.createElement(node);
            if (tpl) {
                node.innerHTML = tpl;
            }
            return node;
        }
        function appendTo(target, el) {
            return target.appendChild(el);
        }

        function renderGitalkContainer() {
            var div = create('div');
            div.id = 'gitalk-container';
            var main = getNode('#site-main');
            div.style = 'width: ' + main.clientWidth + 'px; margin: 0 auto 20px;';
            appendTo(find('#gitalk-component-wrap'), div);
            var script = create('script');
            var content = "gitalk.render('gitalk-container')";
        }
        renderGitalkContainer();

        var gitalk = new Gitalk({
            clientID: 'a65ee9e3ea5168da1470',
            clientSecret: 'ebfd520679d1ad61929b1887b2efccd4872389e3',
            repo: 'boycgit.github.io',
            owner: 'boycgit',
            admin: [
                'boycgit'
            ],
            id: location.pathname,
            // facebook-like distraction free mode
            distractionFreeMode: false
        });
        gitalk.render('gitalk-container');



        var postImages = document.querySelectorAll('.post-content img');
        Array.prototype.forEach.call(postImages, function (el, i) {
            el.outerHTML = `<aholder href="${el.src}" data-lightbox="postImages" data-title="${el.alt}">${el.outerHTML}</aholder>`.replace(/aholder/g, 'a');
        });

        // 动态添加 js 脚本
        setTimeout(function(){
            var script = document.createElement("script");
            script.type = "text/javascript";
            script.src = "https://cdn.jsdelivr.net/npm/lightbox2@2.10.0/dist/js/lightbox.min.js";
            document.getElementsByTagName('body')[0].appendChild(script);

            script.onload = function () {

                console.log('load success');
            }
        }, 1000);

    })();
</script>


        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="https://boycgit.github.io">JSCON-简时空</a> © 2019</section>
                <nav class="site-footer-nav">
                    <a href="https://boycgit.github.io">最新文章</a>
                    
                    
                    <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a>
                </nav>
            </div>
        </footer>

    </div>


    <script src="https://code.jquery.com/jquery-3.2.1.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous">
    </script>
    <script type="text/javascript" src="../assets/js/jquery.fitvids.js?v=11f1923694"></script>


    <script>

// NOTE: Scroll performance is poor in Safari
// - this appears to be due to the events firing much more slowly in Safari.
//   Dropping the scroll event and using only a raf loop results in smoother
//   scrolling but continuous processing even when not scrolling
$(document).ready(function () {
    // Start fitVids
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
    // End fitVids

    var progressBar = document.querySelector('#reading-progress');
    var header = document.querySelector('.floating-header');
    var title = document.querySelector('.post-full-title');

    var lastScrollY = window.scrollY;
    var lastWindowHeight = window.innerHeight;
    var lastDocumentHeight = $(document).height();
    var ticking = false;

    function onScroll() {
        lastScrollY = window.scrollY;
        requestTick();
    }

    function onResize() {
        lastWindowHeight = window.innerHeight;
        lastDocumentHeight = $(document).height();
        requestTick();
    }

    function requestTick() {
        if (!ticking) {
            requestAnimationFrame(update);
        }
        ticking = true;
    }

    function update() {
        var trigger = title.getBoundingClientRect().top + window.scrollY;
        var triggerOffset = title.offsetHeight + 35;
        var progressMax = lastDocumentHeight - lastWindowHeight;

        // show/hide floating header
        if (lastScrollY >= trigger + triggerOffset) {
            header.classList.add('floating-active');
        } else {
            header.classList.remove('floating-active');
        }

        progressBar.setAttribute('max', progressMax);
        progressBar.setAttribute('value', lastScrollY);

        ticking = false;
    }

    window.addEventListener('scroll', onScroll, {passive: true});
    window.addEventListener('resize', onResize, false);

    update();

});
</script>


    <script>
  document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body);
  });
</script>

</body>
</html>

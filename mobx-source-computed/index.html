
<!DOCTYPE html><html lang="zh">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>【用故事解读 MobX源码（二）】 computed</title>
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" type="text/css" href="../assets/built/screen.css?v=a3b4af4713">

    <meta name="description" content="网上已有很多关于 MobX 源码解读的文章，但大多阅读成本甚高。本人在找文章时对此深有体会，故将以系列故事的方式展现源码逻辑，尽可能以易懂的方式讲解 MobX 源码。本文分析 computed 源码运行逻辑。">
    <link rel="shortcut icon" href="../favicon.png" type="image/png">
    <link rel="canonical" href="https://boycgit.github.io/mobx-source-computed/">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <link rel="amphtml" href="https://boycgit.github.io/mobx-source-computed/amp/">
    
    <meta property="og:site_name" content="JSCON-简时空">
    <meta property="og:type" content="article">
    <meta property="og:title" content="【用故事解读 MobX源码（二）】 computed">
    <meta property="og:description" content="网上已有很多关于 MobX 源码解读的文章，但大多阅读成本甚高。本人在找文章时对此深有体会，故将以系列故事的方式展现源码逻辑，尽可能以易懂的方式讲解 MobX 源码。本文分析 computed 源码运行逻辑。">
    <meta property="og:url" content="https://boycgit.github.io/mobx-source-computed/">
    <meta property="og:image" content="https://boycgit.github.io/content/images/2018/08/accountant-1238598_1280.jpg">
    <meta property="article:published_time" content="2018-04-08T08:10:00.000Z">
    <meta property="article:modified_time" content="2019-06-20T05:26:20.000Z">
    <meta property="article:tag" content="mobx">
    <meta property="article:tag" content="javascript">
    <meta property="article:tag" content="源码">
    <meta property="article:tag" content="源码分析">
    
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="【用故事解读 MobX源码（二）】 computed">
    <meta name="twitter:description" content="网上已有很多关于 MobX 源码解读的文章，但大多阅读成本甚高。本人在找文章时对此深有体会，故将以系列故事的方式展现源码逻辑，尽可能以易懂的方式讲解 MobX 源码。本文分析 computed 源码运行逻辑。">
    <meta name="twitter:url" content="https://boycgit.github.io/mobx-source-computed/">
    <meta name="twitter:image" content="https://boycgit.github.io/content/images/2018/08/accountant-1238598_1280.jpg">
    <meta name="twitter:label1" content="Written by">
    <meta name="twitter:data1" content="boycgit">
    <meta name="twitter:label2" content="Filed under">
    <meta name="twitter:data2" content="mobx, javascript, 源码, 源码分析">
    <meta property="og:image:width" content="1280">
    <meta property="og:image:height" content="853">
    
    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "publisher": {
        "@type": "Organization",
        "name": "JSCON-简时空",
        "logo": "https://boycgit.github.io/content/images/2018/08/logoicon.png"
    },
    "author": {
        "@type": "Person",
        "name": "boycgit",
        "image": {
            "@type": "ImageObject",
            "url": "//www.gravatar.com/avatar/8b26b02c66a0e37c2183431d58502c25?s=250&d=mm&r=x",
            "width": 250,
            "height": 250
        },
        "url": "https://boycgit.github.io/author/boycgit/",
        "sameAs": []
    },
    "headline": "【用故事解读 MobX源码（二）】 computed",
    "url": "https://boycgit.github.io/mobx-source-computed/",
    "datePublished": "2018-04-08T08:10:00.000Z",
    "dateModified": "2019-06-20T05:26:20.000Z",
    "image": {
        "@type": "ImageObject",
        "url": "https://boycgit.github.io/content/images/2018/08/accountant-1238598_1280.jpg",
        "width": 1280,
        "height": 853
    },
    "keywords": "mobx, javascript, 源码, 源码分析",
    "description": "网上已有很多关于 MobX 源码解读的文章，但大多阅读成本甚高。本人在找文章时对此深有体会，故将以系列故事的方式展现源码逻辑，尽可能以易懂的方式讲解 MobX 源码。本文分析 computed 源码运行逻辑。",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://boycgit.github.io/"
    }
}
    </script>

    <script src="../public/ghost-sdk.js?v=a3b4af4713"></script>
<script>
ghost.init({
	clientId: "ghost-frontend",
	clientSecret: "7c2ea2eb9409"
});
</script>
    <meta name="generator" content="Ghost 2.31">
    <link rel="alternate" type="application/rss+xml" title="JSCON-简时空" href="https://boycgit.github.io/rss/">
    <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-69473481-3"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-69473481-3');
</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-beta/dist/katex.min.css" integrity="sha384-9tPv11A+glH/on/wEu99NVwDPwkMQESOocs/ZGXPoIiLE8MU/qkqUcZ3zzL+6DuH" crossorigin="anonymous">
<style>

/* 结束 */

  .end-block-wrap{
        color:#338daf;
        text-align: center;
    }

    .end-block-wrap img{
        border: none;
        max-width: 100%;
        margin: 0px auto; display: inline-block;
    }

    .end-block-wrap img.main{
        width: 30px;
    }


/* 参考文档 */
.ref-wrap .line-text{
    display: flex;justify-content:center;align-items:flex-end;
}

.ref-wrap .line-text::before, .ref-wrap .line-text::after{
    content: '';
    display: inline-block;
    width: 25%; border-bottom: 1px dashed rgb(51, 51, 51); box-sizing: border-box;
}

.ref-wrap .text.main{
    font-size: 14px; 
    color: rgb(0, 0, 0); 
    letter-spacing: 1.5px; 
    padding: 0px 10px; 
    font-weight: bold; 
    margin-bottom: -5px; 
    box-sizing: border-box;
}

.ref-wrap  .text.second{
    font-size: 16px; 
    color: rgb(0, 0, 0); 
    letter-spacing: 1.5px; 
    padding: 10px; 
    text-align: center; 
    box-sizing: border-box;
}
/* 求关注 */
.qr-wrap{
    margin-right: auto; 
    margin-left: auto; 
    width: 360px; 
    border: none rgb(255, 129, 36); 
    background: url(https://mpt.135editor.com/mmbiz_gif/ziadDDQxbCJFA2XMwm7VE1RTcS94u8LqVWSjIasMfzY8aG5HolkBhHhwEp0eUpPCEzPYqXYicbRNtROJibbM9P55g/0?wx_fmt=gif) right 0px no-repeat; 
    background-size: contain; 
    box-sizing: border-box;
}

.qr-image{
    padding: 10px 3px; 
    width: 150px; 
    display: inline-block; 
    box-sizing: border-box;
}

.qr-image img{
    width: 150px;
}


</style>

</head>
<body class="post-template tag-mobx tag-javascript tag-yuan-ma tag-yuan-ma-fen-xi">

    <div class="site-wrapper">

        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.3.3/dist/gitalk.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightbox2@2.10.0/dist/css/lightbox.min.css">



<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
                <a class="site-nav-logo" href="https://boycgit.github.io"><img src="../content/images/2018/08/logoicon.png" alt="JSCON-简时空"></a>
            <ul class="nav" role="menu">
    <li class="nav-shou-ye" role="menuitem"><a href="https://boycgit.github.io/">首页</a></li>
    <li class="nav-guan-yu" role="menuitem"><a href="https://boycgit.github.io/about-me/">关于</a></li>
</ul>

    </div>
    <div class="site-nav-right">
        <div class="social-links">
        </div>
            <a class="rss-button" href="https://feedly.com/i/subscription/feed/https://boycgit.github.io/rss/" target="_blank" rel="noopener"><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24"><circle cx="6.18" cy="17.82" r="2.18"></circle><path d="M4 4.44v2.83c7.03 0 12.73 5.7 12.73 12.73h2.83c0-8.59-6.97-15.56-15.56-15.56zm0 5.66v2.83c3.9 0 7.07 3.17 7.07 7.07h2.83c0-5.47-4.43-9.9-9.9-9.9z"></path></svg>
</a>
    </div>
</nav>
    </div>
</header>


<main id="site-main" class="site-main outer">
    <div class="inner">

        <article class="post-full post tag-mobx tag-javascript tag-yuan-ma tag-yuan-ma-fen-xi ">

            <header class="post-full-header">
                <section class="post-full-meta">
                    <time class="post-full-meta-date" datetime="2018-04-08">8 April 2018</time>
                        <span class="date-divider">/</span> <a href="../tag/mobx/">mobx</a>
                </section>
                <h1 class="post-full-title">【用故事解读 MobX源码（二）】 computed</h1>
            </header>

            <figure class="post-full-image" style="background-image: url(../content/images/2018/08/accountant-1238598_1280.jpg)">
            </figure>

            <section class="post-full-content">
                <div class="post-content">
                    <!--kg-card-begin: markdown--><p><code>================前言===================</code></p>
<ul>
<li>
<p><strong>初衷</strong>：以系列故事的方式展现 MobX 源码逻辑，尽可能以易懂的方式讲解源码；</p>
</li>
<li>
<p><strong>本系列文章</strong>：</p>
<ul>
<li>《<a href="https://segmentfault.com/a/1190000013682735">【用故事解读 MobX源码（一）】 autorun</a>》</li>
<li>《<a href="https://segmentfault.com/a/1190000014238836">【用故事解读 MobX源码（二）】 computed</a>》</li>
<li>《<a href="https://segmentfault.com/a/1190000014726483">【用故事解读 MobX源码（三）】 shouldCompute</a>》</li>
<li>《<a href="https://segmentfault.com/a/1190000015481998">【用故事解读 MobX 源码（四）】装饰器 和 Enhancer</a>》</li>
<li>《<a href="https://segmentfault.com/a/1190000015875144">【用故事解读 MobX 源码（五）】 Observable</a>》</li>
</ul>
</li>
<li>
<p><strong>文章编排</strong>：每篇文章分成两大段，第一大段以简单的侦探系列故事的形式讲解（<strong>所涉及人物、场景都以 MobX 中的概念为原型创建</strong>），第二大段则是相对于的源码讲解。</p>
</li>
<li>
<p><strong>本文基于 MobX 4 源码讲解</strong><br>
<code>=======================================</code></p>
</li>
</ul>
<p>在写本文的时候，由于 MobX 以及升级到 4.x，API 有较大的变化，因此后续的文章默认都将基于 4.x 以上版本进行源码阅读。</p>
<p><a href="https://segmentfault.com/a/1190000013682735">前一篇文章</a>仍然以 mobx v3.5.1 的源码，<code>autorun</code> 逻辑在新版中没有更改，因此源码逻辑仍旧一致。</p>
<h1 id="astorytime">A. Story Time</h1>
<h2 id="1">1、 场景</h2>
<p>为了多维度掌控嫌疑犯的犯罪特征数据，你（警署最高长官）想要获取并实时监控张三的 <strong>贷款数额、存贷比（存款和贷款两者比率）</strong> 的变化。</p>
<p>于是你就拟定了新的命令给执行官 MobX：</p>
<pre><code class="language-js">var bankUser = mobx.observable({
  income: 3,
  debit: 2
});

var divisor = mobx.computed(() =&gt; {
  return bankUser.income / bankUser.debit;
});

mobx.autorun(() =&gt; {
  console.log('张三的贷款：', bankUser.debit, '；张三的存贷比: ' + divisor);
});

</code></pre>
<p>相比上一次的命令，除了监控张三贷款这项直接的指标，还需要监控 <strong>贷款比</strong>（<code>divisor</code>） 这项间接指标。</p>
<p>执行官 MobX 稍作思忖，要完成这个任务比之前的要难一点点，需要费一点儿精力。</p>
<p><img src="https://raw.githubusercontent.com/boycgit/web-image/master/blog20190620130025.png" alt="执行官 MobX 稍作思忖"></p>
<p>不过，这也难不倒能力强大的 MobX 执行官，一番策略调整之后，重新拿出新的执行方案。部署实施之后，当张三去银行存款、贷款后，这些变化都实时反馈出来了：</p>
<p><img src="https://img.alicdn.com/tfs/TB1QmAHfr9YBuNjy0FgXXcxcXXa-844-446.gif" alt="实时反馈计算值"></p>
<h2 id="2">2、部署方案</h2>
<p>这次的部署和前一次相差不大，除了需要让观察员 O2（监视 <code>income</code>）参与进来之外，考虑到警署最高长官所需的 <strong>存贷比</strong> （<code>divisor</code>），还得派出另一类职员 ——  <strong>会计师</strong>：</p>
<ul>
<li><strong>会计师</strong>：此类职员专门负责计算，从事 <strong>数据的再加工</strong>（此项任务中，就是搜集数据并计算 <strong>存贷比</strong>）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/boycgit/web-image/master/blog20190620130239.png" alt="会计师角色"></p>
<p>会计师是一个很有意思的角色，要想理解他们，必须得思考他们的数据“从哪儿来？到哪里去？” 这两个问题：</p>
<ul>
<li>从哪儿来：从<strong>观察员</strong>那儿获取，也可以从<strong>其他会计师</strong>那儿获取；</li>
<li>到哪儿去：所生产的数据，要么是被<strong>探长</strong>消费，要么被<strong>其他会计师</strong>所用；（当然，没有人消费他所生产的数据也是可能的，不过这就得追究 MobX 执行官的责任了，浪费了人力资源）</li>
</ul>
<p>引入了会计师角色之后，MobX 执行官重新绘制了部署计划图：</p>
<p><img src="https://raw.githubusercontent.com/boycgit/web-image/master/blog20190620130251.png" alt="重新绘制部署计划图"></p>
<p>解释一下此计划图的意思：</p>
<ol>
<li>明确此次任务是 <strong>当张三账户存款或者贷款变更时，打印其贷款数额（<code>debit</code>）和存贷比（<code>divisor</code>）</strong>：</li>
</ol>
<pre><code class="language-js">() =&gt; {
  console.log('张三的贷款：', bankUser.debit, '；张三的存贷比: ' + divisor);
}
</code></pre>
<ol start="2">
<li>将任务指派给执行组中的探长 R1</li>
<li>派遣 2 名观察组中的观察员 O1、O2 分别监察张三账户的 <code>bankUser.income</code> 属性和 <code>bankUser.debit</code> 属性；</li>
<li>派遣计算组中的会计师 C1 计算张三的贷款比，其所需数值来源于观察员 O1、O2；</li>
<li>探长 R1 任务中所需的“张三的账户存款” 数值从观察员 O2 那儿获取；所需的 “张三的存贷比” 数值从会计师 C1 那儿获取；</li>
<li>同时架设数据情报室，方便信息交换；</li>
</ol>
<h3 id="21">2.1、部署细节</h3>
<p>因为还是 <code>autorun</code> 命令，所以仍然执行 A计划方案（详情参考上一篇《<a href="https://segmentfault.com/a/1190000013682735">【用故事解读 MobX源码（一）】 autorun</a>》）MobX 执行官的部署方案从整体上看是一样的，考虑到多了<strong>会计师</strong>这个角色的参与，所以特意在探长 <strong>获取存贷比（<code>divisor</code>）</strong> 逻辑处空出一部分留给会计师让它自由发挥：</p>
<p><img src="https://raw.githubusercontent.com/boycgit/web-image/master/blog20190620130411.png" alt="会计师角色位置"></p>
<blockquote>
<p>这样做，MobX 执行官也为了在实际行动中向他的警署长官证实该 A计划方案 的确拥有“良好的扩展性”。</p>
</blockquote>
<p>解开这层新增的会计师计算逻辑 “面纱”，图示如下：</p>
<p><img src="https://raw.githubusercontent.com/boycgit/web-image/master/blog20190620130440.png" alt="会计师计算逻辑图"></p>
<p>你会发现历史总是惊人的相似，新增的会计师执行计算任务的逻辑其实 <strong>探长</strong> 执行任务的逻辑是一样的，下图中我特意用 <strong>相同的序号（不同的颜色形状）标示</strong> 出，序号所对应含义如下：</p>
<ol>
<li>设置成 <strong>正在执勤人员</strong></li>
<li>开始执行任务</li>
<li>从观察员或会计师那儿获取执行任务所需的数值，并同他们取得联系，</li>
<li>计算任务执行完成后，更新与观察员 O1、观察员 O2 之间的联系；</li>
</ol>
<p><img src="https://raw.githubusercontent.com/boycgit/web-image/master/blog20190620130515.png" alt="会计师执行计算任务的逻辑和探长几乎一致"></p>
<p>此执行计算任务的逻辑，如果不告诉观察员的话，观察员还以为又来了一名“探长”上级。</p>
<p>从部署图里我们可以看出会计师具有两面性；</p>
<ol>
<li>对探长而言：会计师和观察员地位差不多，都属于“下级”，都需要将自己的信息及时反馈给探长；</li>
<li>对观察员而言：会计师是属于 “上级”，拥有部分类似探长执行任务权力，只不过其任务类型只能是 <strong>计算类型</strong>的任务，执行任务结束之后，像探长那样和观察员互相关联起来，方便下一次的运算；</li>
</ol>
<p>自从有了会计师的参与，探长还是那个探长，但他的下级已经不是之前的下级了。借助 A计划任务的执行，会计师 C1 在上报计算值的时候，会顺水推舟地执行计算任务，同时更新他的 ”<strong>关系网</strong>“。</p>
<h3 id="22">2.2、 懒惰的会计师</h3>
<p>会计师有一个特性就是<strong>比较懒</strong>：就算观察员所观察到的值变更了，他们也不会立即重新计算，而只在必要的时候（比如<strong>当上级前来索取时</strong>）才会重新计算。</p>
<p>举个例子，当观察员 O1 发现张三的账户存款从原来的 3 变成 6 ：</p>
<pre><code class="language-js">bankUser.income = 6;
</code></pre>
<p>这个时候会触发一系列的 “涟漪”：</p>
<ul>
<li>① 观察员 O1 先注册事务，相当于到数据情报室”上班打卡“，声明这次事件由 观察员 O1 主导</li>
<li>② 告知其上级，也就是会计师 C1 ，说是张三存款（<code>income</code>）有变更</li>
<li>③  会计师 C1 获知消息后，”慵懒地“调整自己的状态</li>
<li>④  随后会计师 C1 继续往上级汇报，告知本会计师的值有更改（注意，此时<strong>会计师只是告诉上级自己的值有更改这一事实，但并没有执行计算任务</strong> ！）</li>
<li>⑤  探长 R1 接收到会计师的反馈后，就向 MobX 执行官申请要执行任务！因为其下级会计师 C1 汇报说值有更改，说明这个时候应该要重新执行任务啦~</li>
<li>⑥  执行官 MobX 调阅数据情报室信息一看，发现目前观察员 O1 正在执行事务，就让探长 R1 再等等，现在不是执行任务的最佳时机，等到事务结束再说。</li>
<li>⑦  不一会儿观察员 O1 完成了自己的职责，”下班打卡“，在数据情报室中注销事务</li>
<li>⑧  这个时候，执行官 MobX 才让探长 R1 开始执行任务</li>
</ul>
<p>将上面的文字转换成流程图，可以清晰看到各角色在这次“涟漪”中所起到的作用：</p>
<p><img src="https://raw.githubusercontent.com/boycgit/web-image/master/blog20190620130629.png" alt="会计师惰性求值"></p>
<p>这里需要注意 3 点：</p>
<ol>
<li>当观察员O1 汇报张三存款有更改的时候，会计师 C1 并没有立即重新计算值哦，仅仅是更改自身的状态；</li>
<li>会计师告知上级（探长 R1）自己有值更改，探长申请执行任务，不过 MobX 执行官并没有允许他这么做，而是让他先等待一下，因为此时 <strong>观察员 O1</strong> 还在汇报工作。等观察员 O1 工作汇报完毕，这个时候才让探长执行任务。因为有可能有其他计算组职员也正在响应该观察值的更改，事情一件一件来，不要着急，这和 debounce 思想一致，减少不必要的计算。</li>
<li>只有在最后探长执行任务时 <strong>需要用到会计师的值的时候，会计师才会去执行计算操作</strong>。这就是典型的惰性求值思维。</li>
</ol>
<p>会计师这种拖延到 <strong>只有被需要的时候才进行计算</strong> 的行为，有没有让你回忆起学生时代寒假结束前一天疯狂补作业的场景？</p>
<p><img src="https://raw.githubusercontent.com/boycgit/web-image/master/blog20190620130719.png" alt="疯狂补作业的场景"></p>
<h3 id="23">2.3、避免不必要的计算</h3>
<p>当执行官 MobX 拿着这份执行报告送达给你（警署最高长官），阅览完毕：”不错，这套方案的确部分证实了你之前所言的可扩展性。但随着职员的引入，运转机构逐渐庞大，如何避免不必要的开销的呢？“</p>
<p>”长官您高瞻远瞩，这的确是一个问题。在井然有序的规则下，个别职员的运作效率的确会打折扣。因此避免职员不必要的计算开销，也是在我方案部署规划之内。正如您所见，上述方案中会计师的‘惰性’、探员在事务之后再进行任务等机制，都是基于优化性能所采取的措施。“ 执行官 MobX 稍作停顿，继续道，”为了更好地阐述这套运行方案的性能优化机制，我明天呈上一份报告，好让您得以全面了解。“</p>
<p>”Good Job！期待你的报告“。</p>
<p>那么，执行官 MobX 是凭借什么机制减少开销的呢？且听下回分解。<br>
（本节完，未完待续）</p>
<h1 id="bsourcecodetime">B. Source Code Time</h1>
<p>本节部分，仍然是就着上面的”故事“来讲 MobX 中的源码。</p>
<p>先罗列本文故事中新出现的 <strong>会计师</strong> 角色与 MobX 源码概念映射关系：</p>
<table>
<thead>
<tr>
<th>故事人物</th>
<th>MobX 源码</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>会计师</td>
<td><a href="https://github.com/mobxjs/mobx/blob/master/src/core/computedvalue.ts">computedvalue</a></td>
<td>官方文档 - <a href="http://cn.mobx.js.org/refguide/computed-decorator.html">(@)computed 计算值</a></td>
</tr>
</tbody>
</table>
<blockquote>
<p>探长、执行官等角色的映射关系，参考上一篇《<a href="https://segmentfault.com/a/1190000013682735">【用故事解读 MobX源码（一）】 autorun</a>》</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/boycgit/web-image/master/blog20190620130743.png" alt="会计师对应于 MobX 中的 ComputedValue"></p>
<p>本文的重点内容就是 <a href="https://github.com/mobxjs/mobx/blob/master/src/core/computedvalue.ts">computedvalue</a> 的部分源码（它在 <code>autorun</code> 等场景中的应用）</p>
<p><code>autorun</code>（A 计划）的源码在上一节讲过，这里不再赘述。我们仅仅讲解一下 <strong>computedValue</strong> 在 <code>autorun</code> 中的表现。</p>
<h2 id="1">1、会计师，请开始你的表演</h2>
<p>在故事中我们讲到过，当探长向会计师索要计算值的时候，此时懒惰的会计师为了 ”应付交差“，这时候才开始计算，其计算的过程和探长执行的任务流程几乎一致。</p>
<p>从源码角度去看一下其中的原因。</p>
<p>当探长执行任务：</p>
<pre><code class="language-js">() =&gt; {
  console.log('张三的贷款：', bankUser.debit, '；张三的存贷比: ' + divisor);
}
</code></pre>
<p>任务中也涉及 <code>bankUser.debit</code> 变量和 <code>divisor</code> 变量；其中在获取 <code>bankUser.debit</code> 变量之时会让观察员 O2 触发 <code>reportObserved</code>方法，这个上一篇文章着重讲过，此处就不详细展开了；而请求 <code>divisor</code> 数值的时候，则会触发该值的 <code>valueOf()</code> 方法 —— 即调用会计师（<strong>computedValue</strong>）的 <code>valueOf()</code> 方法。</p>
<p>为什么调用就触发 <code>valueOf()</code> 方法呢？请看下方的“知识点”备注?</p>
<blockquote>
<p>======== 插播知识点 =========</p>
</blockquote>
<blockquote>
<p>任何原始值还是对象其实都包含 <code>valueOf()</code> 或 <code>toString()</code> 方法，<code>valueOf()</code> 会返回最适合该对象类型的原始值，<code>toString()</code> 将该对象的原始值以字符串形式返回。<br>
这两个方法一般是交由 JS 去隐式调用，以满足不同的运算情况。比如在数值运算（如<code>a + b</code>）里会优先调用 <code>valueOf()</code>，而在字符串运算（如alert(<code>c</code>)）里，会优先调用 <code>toString()</code> 方法<br>
顺带附上两篇 参考文章</p>
</blockquote>
<ul>
<li><a href="https://www.zhihu.com/question/24262399">js中 toString 和 valueOf 的区别？</a>：知乎问答</li>
<li><a href="https://stackoverflow.com/questions/2485632/valueof-vs-tostring-in-javascript">valueOf() vs. toString() in Javascript</a>：SF 上的回答，非常详尽地告诉你其执行结果</li>
</ul>
<blockquote>
<p>======== 完毕 ==========</p>
</blockquote>
<p>一旦调用调用会计师的 <a href="https://github.com/mobxjs/mobx/blob/4.1.1/src/core/computedvalue.ts#L283">valueOf</a> 方法：</p>
<pre><code class="language-js">valueOf(): T {
    return toPrimitive(this.get())
}
</code></pre>
<p>其实就是调用 <a href="https://github.com/mobxjs/mobx/blob/4.1.1/src/core/computedvalue.ts#L142">this.get()</a> 方法，我们瞧一眼源码；</p>
<p><img src="https://raw.githubusercontent.com/boycgit/web-image/master/blog20190620130838.png" alt="会计师（computedValue）的 valueOf() 方法"></p>
<h3 id="11">1.1、 <strong>重量级计算</strong> 还是 <strong>轻量级</strong> 计算？</h3>
<p>这里有个分叉点，根据 <code>globalState.inBatch</code> 决定到底是启用 <strong>重量级计算</strong> 还是 <strong>轻量级计算</strong>：</p>
<ul>
<li>当 <code>globalState.inBatch</code> 值大于 <strong>0</strong>，说明会计师被上级征调（处于上级事务中），比如此案例中，陷于 A 计划（<code>autorun</code>）的会计师，在上级探长 R1 需要查阅计算值时候，就会进入<strong>重量级计算</strong>模式</li>
<li>当会计师无上级征调的时候，<code>globalState.inBatch</code> 值为 <strong>0</strong>，就会进入<strong>轻量级计算</strong>模式，简化计算的逻辑。</li>
</ul>
<p>但无论轻量级还是重量级计算，都会涉及到调用 <a href="https://github.com/mobxjs/mobx/blob/4.1.1/src/core/computedvalue.ts#L209">computeValue()</a> 方法来执行计算任务。</p>
<p>调用的时候，如果是 <strong>重量级计算</strong> 则 <code>track</code> 这个 bool 值为 <strong>true</strong>，否则<code>track</code> 值为 <strong>false</strong>。</p>
<p><img src="https://raw.githubusercontent.com/boycgit/web-image/master/blog20190620130930.png" alt="区分轻量级和重量级计算的差别"></p>
<p>计算值有个属性，<code>this.derivation</code> 就是会计师要计算数值时所依据的<strong>计算表达式</strong>，也就是而我们定义会计师时所传入的匿名函数：</p>
<pre><code class="language-js">() =&gt; {
  return bankUser.income / bankUser.debit;
}
</code></pre>
<p>无论是 <strong>重量级计算</strong> 模式还是 <strong>轻量级计算</strong> 模式，<strong>最终都是会调用该计算表达式获取计算值</strong>。</p>
<p><strong>重量级计算</strong> 模式和 <strong>轻量级计算</strong> 模式两者的差别只是在于前者在执行该计算表达式之前会设置很多环境，后者直接就按这个表达式计算数值返回。</p>
<p>在上述的故事中，由于探长 R1 人物的存在，会计师会执行 <strong>重量级计算</strong> 模式，接下来的源码分析也走这条分支路线。（ <strong>轻量级计算</strong> 模式的情况当做课后思考题）。</p>
<h3 id="12">1.2、像探长学习</h3>
<p>在 <strong>重量级计算</strong>的时候，<code>computeValue(true)</code> 就会走和  <strong>探长</strong> 操作模式一样 <code>trackDerivedFunction</code> 步骤。没错，探长和会计师调用的就是同一个方法，所以他们在执行任务的时候，行为痕迹是一样的，没毛病。</p>
<p><img src="https://raw.githubusercontent.com/boycgit/web-image/master/blog20190620130954.png" alt="重量级计算时和探长执行的计算过程类似"></p>
<blockquote>
<p>如果忘记 <code>trackDerivedFunction</code> 方法内容，请查看 《【用故事解读 MobX源码（一）】 autorun》的 ”2.2.2、trackDerivedFunction“ 部分</p>
</blockquote>
<p>只不过会计师<strong>只能执行计算类的任务</strong>（纯函数）罢了，探长可以执行任意类型的任务。</p>
<p>和探长一样，会计师执行计算任务完毕之后调用 <code>bindDependencies</code> 将绑定 观察员 O1 和 观察员 O2 ；而在执行计算之后，会计师会调用 <code>propagateChangeConfirmed</code> 方法，更改自己和上级 <strong>探长</strong> 的状态 —— 这说明，对探长而言，会计师就相当于 <strong>观察员</strong>的角色，在探长执行任务结束后像观察员一样需要上报自己的计算值，并和 <strong>探长</strong> 取得联系；</p>
<p>这么看会计师还真 ”墙头草，两边倒”。</p>
<p>至此，会计师这个角色以较低的成本就能完美地整合进执行官 MobX 所部署的 A 集合部署方案中。??</p>
<h2 id="2">2、 响应观察值的变化</h2>
<p>一旦张三的账户存款（<code>income</code>）发生变化，将会触发 MobX 所提供的 <a href="https://github.com/mobxjs/mobx/blob/4.1.1/src/core/atom.ts#L52">reportChanged</a> 方法：</p>
<pre><code class="language-js">  public reportChanged() {
      startBatch()
      propagateChanged(this)
      endBatch()
  }
</code></pre>
<blockquote>
<p>注意这里的 <code>startBatch</code> 和 <code>endBatch</code> 方法，说明观察员 O1 发起事务了。</p>
</blockquote>
<h3 id="21">2.1、传递变化的信息</h3>
<p>我们知道（不知道的请阅读上一篇文章）该 <code>reportChanged()</code> 方法中的 <code>propagateChanged()</code> 会触发上级的 <code>onBecomeStale()</code> 方法。</p>
<p>观察员 O1 此时的上级是 <strong>会计师 C1</strong>，其所定义的 <a href="https://github.com/mobxjs/mobx/blob/4.1.1/src/core/computedvalue.ts#L130">onBecomeStale</a> 如下：</p>
<pre><code class="language-js">onBecomeStale() {
    propagateMaybeChanged(this)
}
</code></pre>
<p>看一下 <a href="https://github.com/mobxjs/mobx/blob/4.1.1/src/core/observable.ts#L238">propagateMaybeChanged(this)</a> 源码，也比较简单，主要做了两件事情，① 会计师会调整自身的状态； ②然后触发其上级（探长 R1）的 <code>onBecomeStale()</code> 方法。</p>
<p><img src="https://raw.githubusercontent.com/boycgit/web-image/master/blog20190620131035.png" alt="调用 onBecomeStale 方法"></p>
<p>可见观察员 01 会引起会计师 C1 的响应，而会计师会引起探长 R1 的响应，这种响应“涟漪”就是通过下级触发上级的 <code>onBecomeStale</code> 方法形成的连锁反应。</p>
<blockquote>
<p>不同上级（比如会计师和探长）的 <code>onBecomeStale</code> 定义不同。</p>
</blockquote>
<p>探长的这个 <code>onBecomeStale</code> 方法在上一篇文章的 “3、响应观察值的变化 - propagateChanged”  中我们讲过，探长将请求 MobX 请求重新执行一遍 A 计划方案。</p>
<p>然而，MobX 拒绝了这次请求，让他再等待一下。??</p>
<p>这是因为在 <a href="https://github.com/mobxjs/mobx/blob/4.1.1/src/core/reaction.ts#L198">runReactions</a> 方法中：</p>
<pre><code class="language-js">if (globalState.inBatch &gt; 0 || globalState.isRunningReactions) return
</code></pre>
<p>由于此时 <code>inBatch</code> 是 1（因为观察员执行了 <code>startBatch()</code>），所以会直接 return 掉。</p>
<p>直到观察员执行 <a href="https://github.com/mobxjs/mobx/blob/4.1.1/src/core/observable.ts#L126">endBatch()</a> 的时候，除了会结束本次的上报事务，同时执行官 MobX 会重新执行 <code>runReactions</code> 方法，让久等的探长去执行任务：</p>
<p><img src="https://raw.githubusercontent.com/boycgit/web-image/master/blog20190620131115.png" alt="endBatch 来结束本次事务"></p>
<p>探长在执行任务的时候，就会打印张三的贷款（<code>debit</code>）、存贷比（<code>divisor</code>）了。</p>
<h3 id="22">2.2、虽然懒，但是懒得有技巧</h3>
<p>综上，当张三存款（<code>income</code>）变更，就能让 A 计划（<code>autorun</code>）自动运行，探长会打印张三的贷款（<code>debit</code>）、存贷比（<code>divisor</code>）。</p>
<p>这里需要提及一下，关于会计师重新计算的时机，是在探长执行 <a href="https://github.com/mobxjs/mobx/blob/4.1.1/src/core/derivation.ts#L76">shouldCompute</a> 的时候，探长发现会计师值 <strong>陈旧</strong> 了，就让会计师重新计算：</p>
<p><img src="https://raw.githubusercontent.com/boycgit/web-image/master/blog20190620131154.png" alt="在 shouldCompute 中进行精细化判断"></p>
<p>看看这里，对计算值而言，<code>isComputedValue()</code>（如果是计算值）返回 true，就会执行 <code>obj.get()</code> 方法，这个方法刚才刚讲过，会让会计师执行 <strong>重量型计算操作</strong>，更新自己的计算值。</p>
<p>所以，<strong>这次计算时机并非等到探长执行任务时（真正用到该值）的时候才让其重新计算，和第一次 <code>autorun</code> 的时机不一致</strong>。</p>
<p>估计这是 MobX 考虑到会计师的值肯定需要更新的（已经确定要被探长 R1 用到），还有可能会被其他上级引用，既然迟早要更新的，那就尽可能将更新前置，这样在整体上能降低成本。</p>
<p>更新完之后，在探长执行任务的时候，会计师汇报自己是最新的值了，就不用再重新计算一遍。</p>
<p>虽然懒，但是懒得有技巧。</p>
<p>至此，有关会计师的源码解读已经差不多，后续有想到的再补充。</p>
<h2 id="3">3、其他说明</h2>
<p>本文为了方便说明，所以单独使用 <code>mobx.computed</code> 方法定义计算值，平时使用中更多则是直接应用在 <strong>对象中属性</strong> 上，使用 <strong>get</strong> 语法：</p>
<pre><code class="language-js">var bankUser = mobx.observable({
  income: 3,
  debit: 2,
  get divisor() {
    return this.income / this.debit;
  }
});
</code></pre>
<p>这仅仅是写法上不一样，源码分析的思路是一致的。</p>
<h2 id="4">4、小测试</h2>
<h3 id="411">4.1、测试1</h3>
<p><strong>问题</strong>：当我们更改张三贷款数额 <code>bankUser.debit = 4;</code> 时，请从源码角度解答 MobX 的执行流程是如何的？</p>
<p><strong>参考答案提示</strong>：</p>
<pre><code class="language-js">reportChanged() 
    =&gt; propagateChanged() 
    =&gt; propagateMaybeChanged() 
    =&gt; runReaction() 
    =&gt; track() 
    =&gt; get() 
    =&gt; computeValue() 
    =&gt; bindDependencies()
</code></pre>
<h3 id="422">4.2、测试2</h3>
<p><strong>问题</strong>：如果不存在 <code>autorun</code> （即没有探长参与，仅有观察员和会计师），此时仅改变张三存款数值：</p>
<pre><code class="language-js">var bankUser = mobx.observable({
  income: 3,
  debit: 2
});

var divisor = mobx.computed(() =&gt; {
  return bankUser.income / bankUser.debit;
});

bankUser.income = 6; // 请问此时的执行情况是什么样的？

console.log('张三的存贷比：', divisor)

</code></pre>
<p>请问会计师会重新计算数值么？此时这套系统的执行情况又会是怎么样的呢？</p>
<p><strong>参考答案提示</strong>：会计师此时执行 <strong>轻量级计算模式</strong>。</p>
<h2 id="5">5、小结</h2>
<p>此篇文章讲解 MobX 中 <strong>计算值</strong> （computedValue） 的概念，类比故事中的会计师角色。总结一下 <strong>计算值</strong> （computedValue）的特征：</p>
<ol>
<li>计算值是基于现有状态或其他计算值衍生出的数值，一般是通过 <strong>纯函数</strong> 的方式衍生而得。</li>
<li>一旦观察值更改之后，计算值是能够重新执行计算，不过并非立即执行，而是 <strong>惰性</strong> 的 ———— 只有在必要的时候才会执行计算。</li>
<li>对观察值而言，计算值和 <code>autorun</code>（或<code>reaction</code>） 很像，之所以相似是在 <strong>执行任务</strong> 时都涉及到调用 <code>trackDerivedFunction</code> 方法；而对 <code>autorun</code>（或<code>reaction</code>）而言，计算值和观察值很相，都是数据提供者。</li>
</ol>
<p>正如 <a href="http://cn.mobx.js.org/refguide/computed-decorator.html">官方文档</a> 而言，计算值是高度优化过的，所以尽可能应用他们。</p>
<p><img src="https://raw.githubusercontent.com/boycgit/web-image/master/blog20190620131254.png" alt="官方文档对计算值的说明"></p>
<p>下一篇文章将探讨 MobX 中与 <code>autorun</code> 和 <code>computed</code> 相关的计算性能优化的机制，看看 MobX 如何平衡复杂场景下状态管理时的效率和性能。</p>
<!--kg-card-end: markdown-->
                </div>
            </section>
            <p style="text-align: center">下面的是我的公众号二维码图片，欢迎关注，及时获取最新技术文章。</p>
            <section style="text-align: center"><img src="https://raw.githubusercontent.com/boycgit/web-image/master/blogqrcode2.jpg"></section>
            <script src="https://cdn.jsdelivr.net/npm/katex@0.10.0-beta/dist/katex.min.js" integrity="sha384-U8Vrjwb8fuHMt6ewaCy8uqeUXv4oitYACKdB0VziCerzt011iQ/0TqlSlv8MReCm" crossorigin="anonymous"></script>
            <script src="https://cdn.jsdelivr.net/npm/katex@0.10.0-beta/dist/contrib/auto-render.min.js" integrity="sha384-aGfk5kvhIq5x1x5YdvCp4upKZYnA8ckafviDpmWEKp4afOZEqOli7gqSnh8I6enH" crossorigin="anonymous"></script>


            <section id="gitalk-component-wrap"></section>

            <footer class="post-full-footer">


                    
<section class="author-card">
        <img class="author-profile-image" src="http://www.gravatar.com/avatar/8b26b02c66a0e37c2183431d58502c25?s=250&amp;d=mm&amp;r=x" alt="boycgit">
    <section class="author-card-content">
        <h4 class="author-card-name"><a href="../author/boycgit/">boycgit</a></h4>
            <p>阅读此作者的<a href="../author/boycgit/">更多文章</a>.</p>
    </section>
</section>
<div class="post-full-footer-right">
    <a class="author-card-button" href="../author/boycgit/">阅读更多</a>
</div>


            </footer>


        </article>

    </div>
</main>

<aside class="read-next outer">
    <div class="inner">
        <div class="read-next-feed">
                <article class="read-next-card" style="background-image: url(https://casper.ghost.org/v1.0.0/images/blog-cover.jpg)">
                    <header class="read-next-card-header">
                        <small class="read-next-card-header-sitetitle">— JSCON-简时空 —</small>
                        <h3 class="read-next-card-header-title"><a href="../tag/mobx/">mobx</a></h3>
                    </header>
                    <div class="read-next-divider"><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24"><path d="M13 14.5s2 3 5 3 5.5-2.463 5.5-5.5S21 6.5 18 6.5c-5 0-7 11-12 11C2.962 17.5.5 15.037.5 12S3 6.5 6 6.5s4.5 3.5 4.5 3.5"></path></svg>
</div>
                    <div class="read-next-card-content">
                        <ul>
                            <li><a href="../mobx-source-observable/">【用故事解读 MobX 源码（五）】 Observable</a></li>
                            <li><a href="../mobx-source-enhancer/">【用故事解读 MobX 源码（四）】装饰器 和 Enhancer</a></li>
                            <li><a href="../mobx-source-shouldcompute/">【用故事解读 MobX源码（三）】 shouldCompute</a></li>
                        </ul>
                    </div>
                    <footer class="read-next-card-footer">
                        <a href="../tag/mobx/">查看所有4篇文章 →</a>
                    </footer>
                </article>

                <article class="post-card post tag-mobx tag-javascript tag-yuan-ma-fen-xi tag-yuan-ma">
        <a class="post-card-image-link" href="../mobx-source-shouldcompute/">
            <div class="post-card-image" style="background-image: url(https://images.unsplash.com/photo-1523240524572-9fa79064364a?ixlib=rb-0.3.5&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=1080&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ&amp;s=6da5ce196c64ceaebce9ec6f3640f787)"></div>
        </a>
    <div class="post-card-content">
        <a class="post-card-content-link" href="../mobx-source-shouldcompute/">
            <header class="post-card-header">
                    <span class="post-card-tags">mobx</span>
                <h2 class="post-card-title">【用故事解读 MobX源码（三）】 shouldCompute</h2>
            </header>
            <section class="post-card-excerpt">
                <p>网上已有很多关于 MobX 源码解读的文章，但大多阅读成本甚高。本人在找文章时对此深有体会，故将以系列故事的方式展现源码逻辑，尽可能以易懂的方式讲解 MobX 源码；本文分析 shouldCompute 源码的执行逻辑</p>
            </section>
        </a>
        <footer class="post-card-meta">

            <ul class="author-list">
                <li class="author-list-item">

                    <div class="author-name-tooltip">
                        boycgit
                    </div>

                        <a href="../author/boycgit/" class="static-avatar"><img class="author-profile-image" src="http://www.gravatar.com/avatar/8b26b02c66a0e37c2183431d58502c25?s=250&amp;d=mm&amp;r=x" alt="boycgit"></a>
                </li>
            </ul>

            <span class="reading-time">阅读耗时约 21 分钟</span>

        </footer>
    </div>
</article>

                <article class="post-card post tag-javascript tag-mobx tag-yuan-ma-fen-xi tag-yuan-ma">
        <a class="post-card-image-link" href="../mobx-source-autorun/">
            <div class="post-card-image" style="background-image: url(../content/images/2018/08/111.jpg)"></div>
        </a>
    <div class="post-card-content">
        <a class="post-card-content-link" href="../mobx-source-autorun/">
            <header class="post-card-header">
                    <span class="post-card-tags">javascript</span>
                <h2 class="post-card-title">【用故事解读 MobX源码（一）】 autorun</h2>
            </header>
            <section class="post-card-excerpt">
                <p>网上已有很多关于 MobX 源码解读的文章，但大多阅读成本甚高。本人在找文章时对此深有体会，故将以系列故事的方式展现源码逻辑，尽可能以易懂的方式讲解 MobX 源码；本文分析 autorun 源码的执行逻辑</p>
            </section>
        </a>
        <footer class="post-card-meta">

            <ul class="author-list">
                <li class="author-list-item">

                    <div class="author-name-tooltip">
                        boycgit
                    </div>

                        <a href="../author/boycgit/" class="static-avatar"><img class="author-profile-image" src="http://www.gravatar.com/avatar/8b26b02c66a0e37c2183431d58502c25?s=250&amp;d=mm&amp;r=x" alt="boycgit"></a>
                </li>
            </ul>

            <span class="reading-time">阅读耗时约 30 分钟</span>

        </footer>
    </div>
</article>

        </div>
    </div>
</aside>

<div class="floating-header">
    <div class="floating-header-logo">
        <a href="https://boycgit.github.io">
                <img src="../content/images/2018/08/logo.png" alt="JSCON-简时空 icon">
            <span>JSCON-简时空</span>
        </a>
    </div>
    <span class="floating-header-divider">—</span>
    <div class="floating-header-title">【用故事解读 MobX源码（二）】 computed</div>
    <div class="floating-header-share">
        <div class="floating-header-share-label">分享 <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24">
    <path d="M7.5 15.5V4a1.5 1.5 0 1 1 3 0v4.5h2a1 1 0 0 1 1 1h2a1 1 0 0 1 1 1H18a1.5 1.5 0 0 1 1.5 1.5v3.099c0 .929-.13 1.854-.385 2.748L17.5 23.5h-9c-1.5-2-5.417-8.673-5.417-8.673a1.2 1.2 0 0 1 1.76-1.605L7.5 15.5zm6-6v2m-3-3.5v3.5m6-1v2"></path>
</svg>
</div>
        <a class="floating-header-share-weibo" href="http://service.weibo.com/share/share.php?title=%E7%9C%8B%E5%88%B0%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E3%80%8A%E3%80%90%E7%94%A8%E6%95%85%E4%BA%8B%E8%A7%A3%E8%AF%BB%20MobX%E6%BA%90%E7%A0%81%EF%BC%88%E4%BA%8C%EF%BC%89%E3%80%91%20computed%E3%80%8B%EF%BC%8C%E5%BE%88%E7%B2%BE%E5%BD%A9%EF%BC%8C%E6%83%B3%E5%88%86%E4%BA%AB%E7%BB%99%E5%A4%A7%E4%BC%99%E5%84%BF&amp;url=https://boycgit.github.io/mobx-source-computed/" onclick="window.open(this.href, 'share-weibo', 'width=550,height=235');return false;">
            <?xml version="1.0" standalone="no"?><svg t="1534600204727" class="icon" style="" viewbox="0 0 1026 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4202" xmlns:xlink="http://www.w3.org/1999/xlink" width="16.03125" height="16"><defs><style type="text/css"></style></defs><path d="M1012.49 451.553v0.159c-6.697 20.66-28.861 31.99-49.449 25.288a39.352 39.352 0 0 1-25.287-49.582l-0.067-0.031c20.536-63.6 7.516-136.156-40.315-189.363-47.892-53.212-118.502-73.554-183.731-59.659-21.222 4.537-42.133-9.047-46.638-30.3-4.506-21.253 9.021-42.194 30.239-46.73 91.709-19.563 191.114 8.98 258.467 83.881 67.36 74.839 85.515 176.85 56.781 266.337z" fill="#ffffff" p-id="4203"></path><path d="M740.429 304.348v-0.03c-18.217 3.973-36.178-7.732-40.06-26.01-3.947-18.31 7.763-36.373 25.98-40.254 44.692-9.548 93.143 4.322 125.885 40.781 32.866 36.496 41.631 86.17 27.607 129.772a33.833 33.833 0 0 1-42.562 21.847c-17.782-5.76-27.484-24.914-21.724-42.69h-0.062c6.887-21.346 2.565-45.635-13.46-63.473-16.026-17.818-39.752-24.546-61.604-19.943z m30.05 192.184c-14.46-4.352-24.352-7.326-16.774-26.352 16.333-41.313 18.027-76.964 0.317-102.385-33.31-47.734-124.451-45.133-228.838-1.28 0-0.061-32.799 14.367-24.412-11.704 16.056-51.774 13.645-95.186-11.361-120.192-56.658-56.878-207.304 2.12-336.477 131.64C56.187 463.32 0 566.14 0 655.1 0 825.18 217.503 928.594 430.28 928.594c278.917 0 464.527-162.504 464.527-291.59 0-77.936-65.546-122.193-124.329-140.472zM430.842 867.62c-169.774 16.84-316.35-60.155-327.368-171.96-11.049-111.74 117.72-216.034 287.488-232.873 169.805-16.84 316.355 60.16 327.368 171.904 11.018 111.866-117.683 216.09-287.488 232.929z" fill="#ffffff" p-id="4204"></path><path d="M447.805 548.859c-80.783-21.09-172.119 19.287-207.206 90.65-35.743 72.862-1.188 153.681 80.44 180.1 84.578 27.357 184.233-14.525 218.88-93.148 34.181-76.81-8.478-155.94-92.114-177.602zM386.12 734.792c-16.43 26.29-51.584 37.806-78.065 25.661-26.107-11.889-33.833-42.44-17.403-68.045 16.215-25.538 50.207-36.869 76.498-25.856 26.604 11.392 35.087 41.687 18.97 68.24z" fill="#ffffff" p-id="4205"></path></svg>        </a>
        <a class="floating-header-share-weixin" href="https://cli.im/api/qrcode/code?text=https://boycgit.github.io/mobx-source-computed/&amp;mhid=txbODQq7nZkhMHcqI9xROqg" onclick="window.open(this.href, 'share-weixin','width=480,height=600');return false;">
            <?xml version="1.0" standalone="no"?><svg t="1534604253879" class="icon" style="" viewbox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5477" xmlns:xlink="http://www.w3.org/1999/xlink" width="16" height="16"><defs><style type="text/css"></style></defs><path d="M693.12 347.232c11.776 0 23.36 0.896 35.008 2.176C696.768 203.36 540.672 94.88 362.432 94.88 163.2 94.88 0 230.624 0 403.104c0 99.521 54.272 181.248 145.024 244.736L108.8 756.832l126.72-63.488c45.312 8.896 81.664 18.112 126.912 18.112 11.393 0 22.656-0.513 33.792-1.345-7.04-24.256-11.199-49.6-11.199-76.031C385.088 475.744 521.024 347.232 693.12 347.232zM498.304 248.992c27.393 0 45.376 17.984 45.376 45.248 0 27.136-17.983 45.312-45.376 45.312-27.071 0-54.336-18.176-54.336-45.312C443.968 266.912 471.168 248.992 498.304 248.992zM244.672 339.552c-27.2 0-54.592-18.176-54.592-45.312 0-27.264 27.392-45.248 54.592-45.248 27.2 0 45.248 17.92 45.248 45.248C289.92 321.376 271.872 339.552 244.672 339.552z" p-id="5478" fill="#ffffff"></path><path d="M1024 629.728c0-144.896-145.023-262.976-307.904-262.976-172.479 0-308.224 118.144-308.224 262.976 0 145.28 135.808 262.977 308.224 262.977 36.097 0 72.513-9.024 108.736-18.112l99.392 54.528-27.264-90.624C969.729 783.84 1024 711.456 1024 629.728zM616.128 584.352c-17.984 0-36.224-17.92-36.224-36.224 0-18.048 18.239-36.225 36.224-36.225 27.521 0 45.376 18.177 45.376 36.225C661.504 566.432 643.648 584.352 616.128 584.352zM815.488 584.352c-17.856 0-36.032-17.92-36.032-36.224 0-18.048 18.112-36.225 36.032-36.225 27.264 0 45.376 18.177 45.376 36.225C860.864 566.432 842.752 584.352 815.488 584.352z" p-id="5479" fill="#ffffff"></path></svg>        </a>
    </div>
    <progress id="reading-progress" class="progress" value="0">
        <div class="progress-container">
            <span class="progress-bar"></span>
        </div>
    </progress>
</div>



<script src="https://cdn.jsdelivr.net/npm/gitalk@1.3.3/dist/gitalk.min.js"></script>

<script>
    (function () {
        /**
         * Get Node
         * @param  {String|Element} el
         * @param  {Boolean} noCache
         * @return {Element}
         */
        var cacheNode = {};
        function getNode(el, noCache) {
            if (noCache === void 0) noCache = false;

            if (typeof el === 'string') {
                if (typeof window.Vue !== 'undefined') {
                    return find(el);
                }
                el = noCache ? find(el) : cacheNode[el] || (cacheNode[el] = find(el));
            }

            return el;
        }

        /**
         * Find element
         * @example
         * find('nav') => document.querySelector('nav')
         * find(nav, 'a') => nav.querySelector('a')
         */
        function find(el, node) {
            return node ? el.querySelector(node) : document.querySelector(el);
        }
        function create(node, tpl) {
            node = document.createElement(node);
            if (tpl) {
                node.innerHTML = tpl;
            }
            return node;
        }
        function appendTo(target, el) {
            return target.appendChild(el);
        }

        function renderGitalkContainer() {
            var div = create('div');
            div.id = 'gitalk-container';
            var main = getNode('#site-main');
            div.style = 'width: ' + main.clientWidth + 'px; margin: 0 auto 20px;';
            appendTo(find('#gitalk-component-wrap'), div);
            var script = create('script');
            var content = "gitalk.render('gitalk-container')";
        }
        renderGitalkContainer();

        var gitalk = new Gitalk({
            clientID: 'a65ee9e3ea5168da1470',
            clientSecret: 'ebfd520679d1ad61929b1887b2efccd4872389e3',
            repo: 'boycgit.github.io',
            owner: 'boycgit',
            admin: [
                'boycgit'
            ],
            id: location.pathname,
            // facebook-like distraction free mode
            distractionFreeMode: false
        });
        gitalk.render('gitalk-container');



        var postImages = document.querySelectorAll('.post-content img');
        Array.prototype.forEach.call(postImages, function (el, i) {
            el.outerHTML = `<aholder href="${el.src}" data-lightbox="postImages" data-title="${el.alt}">${el.outerHTML}</aholder>`.replace(/aholder/g, 'a');
        });

        // 动态添加 js 脚本
        setTimeout(function(){
            var script = document.createElement("script");
            script.type = "text/javascript";
            script.src = "https://cdn.jsdelivr.net/npm/lightbox2@2.10.0/dist/js/lightbox.min.js";
            document.getElementsByTagName('body')[0].appendChild(script);

            script.onload = function () {

                console.log('load success');
            }
        }, 1000);

    })();
</script>


        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="https://boycgit.github.io">JSCON-简时空</a> © 2019</section>
                <nav class="site-footer-nav">
                    <a href="https://boycgit.github.io">最新文章</a>
                    
                    
                    <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a>
                </nav>
            </div>
        </footer>

    </div>


    <script src="https://code.jquery.com/jquery-3.2.1.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous">
    </script>
    <script type="text/javascript" src="../assets/js/jquery.fitvids.js?v=a3b4af4713"></script>


    <script>

// NOTE: Scroll performance is poor in Safari
// - this appears to be due to the events firing much more slowly in Safari.
//   Dropping the scroll event and using only a raf loop results in smoother
//   scrolling but continuous processing even when not scrolling
$(document).ready(function () {
    // Start fitVids
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
    // End fitVids

    var progressBar = document.querySelector('#reading-progress');
    var header = document.querySelector('.floating-header');
    var title = document.querySelector('.post-full-title');

    var lastScrollY = window.scrollY;
    var lastWindowHeight = window.innerHeight;
    var lastDocumentHeight = $(document).height();
    var ticking = false;

    function onScroll() {
        lastScrollY = window.scrollY;
        requestTick();
    }

    function onResize() {
        lastWindowHeight = window.innerHeight;
        lastDocumentHeight = $(document).height();
        requestTick();
    }

    function requestTick() {
        if (!ticking) {
            requestAnimationFrame(update);
        }
        ticking = true;
    }

    function update() {
        var trigger = title.getBoundingClientRect().top + window.scrollY;
        var triggerOffset = title.offsetHeight + 35;
        var progressMax = lastDocumentHeight - lastWindowHeight;

        // show/hide floating header
        if (lastScrollY >= trigger + triggerOffset) {
            header.classList.add('floating-active');
        } else {
            header.classList.remove('floating-active');
        }

        progressBar.setAttribute('max', progressMax);
        progressBar.setAttribute('value', lastScrollY);

        ticking = false;
    }

    window.addEventListener('scroll', onScroll, {passive: true});
    window.addEventListener('resize', onResize, false);

    update();

});
</script>


    <script>
  document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body);
  });
</script>

</body>
</html>

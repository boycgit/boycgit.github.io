
<!DOCTYPE html><html lang="zh">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>【用故事解读 MobX 源码（四）】装饰器 和 Enhancer</title>
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" type="text/css" href="../assets/built/screen.css?v=a3b4af4713">

    <meta name="description" content="网上已有很多关于 MobX 源码解读的文章，但大多阅读成本甚高。本人在找文章时对此深有体会，故将以系列故事的方式展现源码逻辑，尽可能以易懂的方式讲解 MobX 源码；本文分析源码中有关装饰器与 enhancer 的执行逻辑">
    <link rel="shortcut icon" href="../favicon.png" type="image/png">
    <link rel="canonical" href="https://boycgit.github.io/mobx-source-enhancer/">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <link rel="amphtml" href="https://boycgit.github.io/mobx-source-enhancer/amp/">
    
    <meta property="og:site_name" content="JSCON-简时空">
    <meta property="og:type" content="article">
    <meta property="og:title" content="【用故事解读 MobX 源码（四）】装饰器 和 Enhancer">
    <meta property="og:description" content="网上已有很多关于 MobX 源码解读的文章，但大多阅读成本甚高。本人在找文章时对此深有体会，故将以系列故事的方式展现源码逻辑，尽可能以易懂的方式讲解 MobX 源码；本文分析源码中有关装饰器与 enhancer 的执行逻辑">
    <meta property="og:url" content="https://boycgit.github.io/mobx-source-enhancer/">
    <meta property="og:image" content="https://images.unsplash.com/photo-1522921190264-372c4181543c?ixlib=rb-0.3.5&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=1080&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ&amp;s=9b52a3b11f518813592e6294fc0fa556">
    <meta property="article:published_time" content="2018-07-04T12:07:00.000Z">
    <meta property="article:modified_time" content="2019-06-21T06:46:48.000Z">
    <meta property="article:tag" content="mobx">
    <meta property="article:tag" content="javascript">
    <meta property="article:tag" content="源码分析">
    <meta property="article:tag" content="源码">
    
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="【用故事解读 MobX 源码（四）】装饰器 和 Enhancer">
    <meta name="twitter:description" content="网上已有很多关于 MobX 源码解读的文章，但大多阅读成本甚高。本人在找文章时对此深有体会，故将以系列故事的方式展现源码逻辑，尽可能以易懂的方式讲解 MobX 源码；本文分析源码中有关装饰器与 enhancer 的执行逻辑">
    <meta name="twitter:url" content="https://boycgit.github.io/mobx-source-enhancer/">
    <meta name="twitter:image" content="https://images.unsplash.com/photo-1522921190264-372c4181543c?ixlib=rb-0.3.5&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=1080&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ&amp;s=9b52a3b11f518813592e6294fc0fa556">
    <meta name="twitter:label1" content="Written by">
    <meta name="twitter:data1" content="boycgit">
    <meta name="twitter:label2" content="Filed under">
    <meta name="twitter:data2" content="mobx, javascript, 源码分析, 源码">
    <meta property="og:image:width" content="1080">
    <meta property="og:image:height" content="720">
    
    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "publisher": {
        "@type": "Organization",
        "name": "JSCON-简时空",
        "logo": "https://boycgit.github.io/content/images/2018/08/logoicon.png"
    },
    "author": {
        "@type": "Person",
        "name": "boycgit",
        "image": {
            "@type": "ImageObject",
            "url": "//www.gravatar.com/avatar/8b26b02c66a0e37c2183431d58502c25?s=250&d=mm&r=x",
            "width": 250,
            "height": 250
        },
        "url": "https://boycgit.github.io/author/boycgit/",
        "sameAs": []
    },
    "headline": "【用故事解读 MobX 源码（四）】装饰器 和 Enhancer",
    "url": "https://boycgit.github.io/mobx-source-enhancer/",
    "datePublished": "2018-07-04T12:07:00.000Z",
    "dateModified": "2019-06-21T06:46:48.000Z",
    "image": {
        "@type": "ImageObject",
        "url": "https://images.unsplash.com/photo-1522921190264-372c4181543c?ixlib=rb-0.3.5&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=1080&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ&s=9b52a3b11f518813592e6294fc0fa556",
        "width": 1080,
        "height": 720
    },
    "keywords": "mobx, javascript, 源码分析, 源码",
    "description": "网上已有很多关于 MobX 源码解读的文章，但大多阅读成本甚高。本人在找文章时对此深有体会，故将以系列故事的方式展现源码逻辑，尽可能以易懂的方式讲解 MobX 源码；本文分析源码中有关装饰器与 enhancer 的执行逻辑",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://boycgit.github.io/"
    }
}
    </script>

    <script src="../public/ghost-sdk.js?v=a3b4af4713"></script>
<script>
ghost.init({
	clientId: "ghost-frontend",
	clientSecret: "7c2ea2eb9409"
});
</script>
    <meta name="generator" content="Ghost 2.31">
    <link rel="alternate" type="application/rss+xml" title="JSCON-简时空" href="https://boycgit.github.io/rss/">
    <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-69473481-3"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-69473481-3');
</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-beta/dist/katex.min.css" integrity="sha384-9tPv11A+glH/on/wEu99NVwDPwkMQESOocs/ZGXPoIiLE8MU/qkqUcZ3zzL+6DuH" crossorigin="anonymous">
<style>

/* 结束 */

  .end-block-wrap{
        color:#338daf;
        text-align: center;
    }

    .end-block-wrap img{
        border: none;
        max-width: 100%;
        margin: 0px auto; display: inline-block;
    }

    .end-block-wrap img.main{
        width: 30px;
    }


/* 参考文档 */
.ref-wrap .line-text{
    display: flex;justify-content:center;align-items:flex-end;
}

.ref-wrap .line-text::before, .ref-wrap .line-text::after{
    content: '';
    display: inline-block;
    width: 25%; border-bottom: 1px dashed rgb(51, 51, 51); box-sizing: border-box;
}

.ref-wrap .text.main{
    font-size: 14px; 
    color: rgb(0, 0, 0); 
    letter-spacing: 1.5px; 
    padding: 0px 10px; 
    font-weight: bold; 
    margin-bottom: -5px; 
    box-sizing: border-box;
}

.ref-wrap  .text.second{
    font-size: 16px; 
    color: rgb(0, 0, 0); 
    letter-spacing: 1.5px; 
    padding: 10px; 
    text-align: center; 
    box-sizing: border-box;
}
/* 求关注 */
.qr-wrap{
    margin-right: auto; 
    margin-left: auto; 
    width: 360px; 
    border: none rgb(255, 129, 36); 
    background: url(https://mpt.135editor.com/mmbiz_gif/ziadDDQxbCJFA2XMwm7VE1RTcS94u8LqVWSjIasMfzY8aG5HolkBhHhwEp0eUpPCEzPYqXYicbRNtROJibbM9P55g/0?wx_fmt=gif) right 0px no-repeat; 
    background-size: contain; 
    box-sizing: border-box;
}

.qr-image{
    padding: 10px 3px; 
    width: 150px; 
    display: inline-block; 
    box-sizing: border-box;
}

.qr-image img{
    width: 150px;
}


</style>

</head>
<body class="post-template tag-mobx tag-javascript tag-yuan-ma-fen-xi tag-yuan-ma">

    <div class="site-wrapper">

        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.3.3/dist/gitalk.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightbox2@2.10.0/dist/css/lightbox.min.css">



<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
                <a class="site-nav-logo" href="https://boycgit.github.io"><img src="../content/images/2018/08/logoicon.png" alt="JSCON-简时空"></a>
            <ul class="nav" role="menu">
    <li class="nav-shou-ye" role="menuitem"><a href="https://boycgit.github.io/">首页</a></li>
    <li class="nav-guan-yu" role="menuitem"><a href="https://boycgit.github.io/about-me/">关于</a></li>
</ul>

    </div>
    <div class="site-nav-right">
        <div class="social-links">
        </div>
            <a class="rss-button" href="https://feedly.com/i/subscription/feed/https://boycgit.github.io/rss/" target="_blank" rel="noopener"><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24"><circle cx="6.18" cy="17.82" r="2.18"></circle><path d="M4 4.44v2.83c7.03 0 12.73 5.7 12.73 12.73h2.83c0-8.59-6.97-15.56-15.56-15.56zm0 5.66v2.83c3.9 0 7.07 3.17 7.07 7.07h2.83c0-5.47-4.43-9.9-9.9-9.9z"></path></svg>
</a>
    </div>
</nav>
    </div>
</header>


<main id="site-main" class="site-main outer">
    <div class="inner">

        <article class="post-full post tag-mobx tag-javascript tag-yuan-ma-fen-xi tag-yuan-ma ">

            <header class="post-full-header">
                <section class="post-full-meta">
                    <time class="post-full-meta-date" datetime="2018-07-04">4 July 2018</time>
                        <span class="date-divider">/</span> <a href="../tag/mobx/">mobx</a>
                </section>
                <h1 class="post-full-title">【用故事解读 MobX 源码（四）】装饰器 和 Enhancer</h1>
            </header>

            <figure class="post-full-image" style="background-image: url(https://images.unsplash.com/photo-1522921190264-372c4181543c?ixlib=rb-0.3.5&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=1080&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ&amp;s=9b52a3b11f518813592e6294fc0fa556)">
            </figure>

            <section class="post-full-content">
                <div class="post-content">
                    <!--kg-card-begin: markdown--><p><code>==========前言============</code></p>
<ul>
<li>
<p><strong>初衷</strong>：以系列故事的方式展现 MobX 源码逻辑，尽可能以易懂的方式讲解源码；</p>
</li>
<li>
<p><strong>本系列文章</strong>：</p>
<ul>
<li>《<a href="https://segmentfault.com/a/1190000013682735">【用故事解读 MobX源码（一）】 autorun</a>》</li>
<li>《<a href="https://segmentfault.com/a/1190000014238836">【用故事解读 MobX源码（二）】 computed</a>》</li>
<li>《<a href="https://segmentfault.com/a/1190000014726483">【用故事解读 MobX源码（三）】 shouldCompute</a>》</li>
<li>《<a href="https://segmentfault.com/a/1190000015481998">【用故事解读 MobX 源码（四）】装饰器 和 Enhancer</a>》👈 you are here</li>
<li>《<a href="https://segmentfault.com/a/1190000015875144">【用故事解读 MobX 源码（五）】 Observable</a>》</li>
</ul>
</li>
<li>
<p><strong>文章编排</strong>：每篇文章分成两大段，第一大段以简单的侦探系列故事的形式讲解（<strong>所涉及人物、场景都以 MobX 中的概念为原型创建</strong>），第二大段则是相对于的源码讲解。</p>
</li>
<li>
<p><strong>本文基于 MobX 4 源码讲解</strong><br>
<code>===========================</code></p>
</li>
</ul>
<p>按照步骤，这篇文章应该写 观察值（<a href="https://cn.mobx.js.org/refguide/observable.html">Observable</a>）的，不过在撰写的过程中发现，如果不先搞明白装饰器和 Enhancer（对这个单词陌生的，先不要着急，继续往下看） ，直接去解释观察值（Observable）会很费劲。<strong>因为在 MobX 中是使用装饰器设计模式实现观察值的</strong>，所以说要先掌握装饰器，才能进一步去理解观察值。</p>
<p>所以这是一篇 “插队” 的文章，用于去理解 MobX 中的装饰器和 Enhancer 概念。</p>
<h1 id="a">A. 本文目标</h1>
<p>本文主要解决我个人在源码阅读中的疑惑：</p>
<ul>
<li>在官方文档 <a href="https://cn.mobx.js.org/best/decorators.html">如何(不)使用装饰器</a> 中，为什么说开启 <a href="https://cn.mobx.js.org/refguide/observable-decorator.html">@observable</a>、<a href="https://cn.mobx.js.org/refguide/computed-decorator.html">@computer</a> 等装饰器语法，是和直接使用 <a href="https://cn.mobx.js.org/best/decorators.html">decorate</a> 是等效的？</li>
<li>在 MobX 源码中时常出现的 <code>Enhancer</code> 到底是个什么概念？它在 MobX 体系中发挥怎样的作用？它和装饰器又是怎么样的一层关系？</li>
</ul>
<p>如果你也有这样的疑惑，不妨继续阅读本文，欢迎一起讨论。</p>
<p>至于 观察值（<a href="https://cn.mobx.js.org/refguide/observable.html">Observable</a>），在本文中你只要掌握住 <a href="https://cn.mobx.js.org/refguide/observable.html">官方文档 observable</a> 的用法就足够了，比如（示例摘自官方文档）：</p>
<pre><code class="language-js">const person = observable({
    firstName: "Clive Staples",
    lastName: "Lewis"
});
person.firstName = "C.S.";

const temperature = observable.box(20);
temperature.set(25);
</code></pre>
<p>对于 <code>observable</code> 方法的源码解析将在下一篇中详细展开，此篇文章不会做过多的讨论。</p>
<h1 id="b">B. 学会装饰器</h1>
<h2 id="1">1、装饰器基础知识</h2>
<p>和其他语言（Python、Java）一样，装饰器语法是借助 <code>@</code> 符号实现的，现在问题就归结到如何用 JS 去实现 <code>@</code> 语法。</p>
<p>对于还不熟悉装饰器语法的读者，这里推荐文章 《<a href="http://taobaofed.org/blog/2015/11/16/es7-decorator/">ES7 Decorator 装饰者模式</a>》，以钢铁侠为例，通过装备特殊的装备就能将普通人变成钢铁侠，简单概括起来就是：</p>
<p><img src="https://raw.githubusercontent.com/boycgit/web-image/master/blog20190621140848.png" alt="通过装备特殊的装备就能将普通人变成钢铁侠"></p>
<p>装饰器设计模式的理念就和上面那样的朴素，在不改造 <strong>托尼·史塔克（Tony Stark）</strong> 本体的前提下，通过加装 <strong>盔甲</strong>、<strong>飞行器</strong> 的方式增强 Tony 的能力，从而“变成”钢铁侠。</p>
<p>有关装饰器使用的文章，还可以参考这两篇参考文章 <a href="https://github.com/rccoder/blog/issues/23">探寻 ECMAScript 中的装饰器 Decorator</a>、<a href="https://www.cnblogs.com/whitewolf/p/details-of-ES7-JavaScript-Decorators.html">细说ES7 JavaScript Decorators</a></p>
<p>文章都比较早，当时写文章的作者都认为在新的 ES7 里会推出标准的 <code>@</code> 语法，然而事后证明官方并没有这个意愿。我们知道目前的 ECMAScript 2015 标准，甚至到 ECMAScript 2018 标准官方都没有提供 <code>@</code> 语法的支持，我们在其他文章中看到的 <code>@</code> 语法都是通过 babel 插件来实现的。</p>
<p>上面提及的参考文章都是属于应用类型的，就是直接使用装饰器语法（即直接使用 <code>@</code> 语法）来展示装饰器的实际应用，而对于如何实现 <code>@</code> 语法并没有提及 —— 那就是如何用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">Object.defineProperty</a> 来实现 <code>@</code> 语法。</p>
<p>道理大家都懂，那么到底如何才能自己动手去实现 <code>@</code> 装饰器语法呢？</p>
<h2 id="2descriptor">2、首先你要理解属性描述符（descriptor）</h2>
<p>在 JS 中，我们借助 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">Object.defineProperty</a> 方法实现装饰器设计模式，该方法签名如下：</p>
<pre><code class="language-js">Object.defineProperty(obj, prop, descriptor)
</code></pre>
<p>其中最核心的其实是 <code>descriptor</code> ——  <strong>属性描述符</strong> 。</p>
<p>属性描述符总共分两种：<strong>数据描述符</strong>（Data descriptor）和 <strong>访问器描述符</strong>（Accessor descriptor）。</p>
<p><strong>描述符必须是两种形式之一，但不能同时是两者</strong>。</p>
<p>比如 <strong>数据描述符</strong>：</p>
<pre><code class="language-js">Object.getOwnPropertyDescriptor(user,'name');

// 输出
/**
{
  "value": "张三",
  "writable": true,
  "enumerable": true,
  "configurable": true
}
**/

</code></pre>
<p>还有 <strong>访问器描述符</strong>：</p>
<pre><code class="language-js">var anim = { 
  get age() { return 5; } 
};
Object.getOwnPropertyDescriptor(anim, "age");
// 输出
/**
{
   configurable: true,
   enumerable: true,
   get: /*the getter function*/,
   set: undefined
 }
**/
</code></pre>
<p>具体可参考 StackOverflow 上的问答 <a href="https://stackoverflow.com/questions/9167181/what-is-a-descriptor">What is a descriptor? </a>；</p>
<p>接下来，我们一起来看一下 babel 中到底是如何实现 <code>@</code> 语法的？</p>
<h2 id="3babel">3、搭建装饰器的 babel 示例</h2>
<p>在理解属性描述符的基础上，我们就可以去看看 babel 对于装饰器 <code>@</code> 语法的内部实现了。</p>
<p>就拿 MobX <a href="https://cn.mobx.js.org/refguide/observable-decorator.html">官方的示例</a> 来讲：</p>
<pre><code class="language-js">import { observable, computed, action } from "mobx";

class OrderLine {
    @observable price = 0;
    @observable amount = 1;

    @computed get total() {
        return this.price * this.amount;
    }
    
    @action.bound
    increment() {
        this.amount++ // 'this' 永远都是正确的
    }
}
</code></pre>
<p>我们并不是真正想要运行上面那段代码，而是想看一下 babel 通过装饰器插件，把上面那段代码中的 <code>@</code> 语法转换成什么样子了。</p>
<p><strong>运行这段代码需要搭建 babel 环境，所以直接扔到浏览器运行会报错的</strong>。按照官方文档 <a href="https://cn.mobx.js.org/best/decorators.html">如何(不)使用装饰器</a> 中的提示，需要借助 <a href="https://www.npmjs.com/package/babel-preset-mobx">babel-preset-mobx</a> 插件，这是一个预设（preset，相当于 babel 插件集合），真正和装饰器有关的是插件是 <a href="https://github.com/loganfsmyth/babel-plugin-transform-decorators-legacy">babel-plugin-transform-decorators-legacy</a>。</p>
<h2 id="4">4、有两种方式看转换之后的代码</h2>
<h3 id="41babel">4.1、 方法一，使用 babel 在线工具</h3>
<p>放到 <a href="https://babeljs.io/repl/#?babili=false&amp;browsers=%3E%202%25&amp;build=&amp;builtIns=false&amp;code_lz=JYWwDg9gTgLgBAbzhARgZwKZQG4EMUA2GANHAMYTgCuMGAJnAL5wBmUlcARCKgB6cBuAFBCyBXGjRwA8lDpYAMsAB2GRELia4AAVSYc-InDBRgZNQF44ABmFaderHkJrcPKsvhWAjMI1btCmpaBgBzDHgYCBhcAgAKAEp1e3soCKooZTgYAAtgNAA6EzM1ACpsvMK3CA8YOy1Gf00mnVwyGGAIZQKUGuU6FpUyNJAMT0TklM1c_ILq2oBqBbgAehW4AHIZtA24QA4bQB34wF-EwHozQGNrQDsPQBC3FsbGIA&amp;debug=false&amp;forceAllTransforms=false&amp;shippedProposals=false&amp;circleciRepo=&amp;evaluate=true&amp;fileSize=false&amp;lineWrap=false&amp;presets=es2015%2Cstage-1&amp;prettier=false&amp;targets=Electron-1.5&amp;version=6.26.0&amp;envVersion=1.6.2">babel 在线工具</a>，粘贴现有的示例代码会报错，不过 babel 给出了友好的提示，因为使用到了装饰器语法，需要安装 <a href="https://github.com/loganfsmyth/babel-plugin-transform-decorators-legacy">babel-plugin-transform-decorators-legacy</a>：</p>
<p><img src="https://raw.githubusercontent.com/boycgit/web-image/master/blog20190621140919.png" alt="使用 babel 在线工具查看转换后的代码"></p>
<p>我们点击左下方的 <strong>Add Plugin</strong> 按钮，在弹出的搜索框里输入关键字 <strong>decorators-legacy</strong>，选择这个插件就可以：</p>
<p><img src="https://raw.githubusercontent.com/boycgit/web-image/master/blog20190621140957.png" alt="点击 Add Plugin 按钮"></p>
<p>选完插件之后，代码就会成功转译：</p>
<p><img src="https://raw.githubusercontent.com/boycgit/web-image/master/blog20190621141018.png" alt="代码转换后的效果"></p>
<p>底下会提示 <strong>require is not defined</strong> 错误，这个错误并不影响你分析装饰器的语法，因为有 <code>@</code> 符号部分都已经转换成 ES5 语法了，只是这个报错无法让这段示例代码运行起来。</p>
<blockquote>
<p>这是因为 Babel 只是将最新的 ES6 语法“翻译”成各大浏览器支持比较好的 ES5 语法，但模块化写法（<code>require</code>语句）本身就不是 ECMAScript 的标准，而是产生了其他的模块化写法标准，例如 CommonJS，AMD,UMD。因此 Babel 转码模块化写法后在浏览器中还是无法运行，此时可以考虑放到 Webpack 这种自动化构建工具环境中，此时 Webpack 是支持模块化写法的</p>
</blockquote>
<p>如果有强迫症的同学，非得想要这段代码运行起来，可以参考下述的 <strong>方法二</strong>。</p>
<h3 id="42demo">4.2、方法二，使用 demo 工程</h3>
<p>官方提供了 <a href="https://github.com/mobxjs/mobx-react-boilerplate">mobx-react-boilerplate</a>，clone 下来之后直接：</p>
<pre><code class="language-js">npm install
npm start
</code></pre>
<blockquote>
<p>说明：package.json 中的 <code>dependencies</code> 字段比较陈旧了，可以自己手动更新到最新版本</p>
</blockquote>
<p>打开控制台就可以看到 <strong>bundle.js</strong> 文件了：</p>
<p><img src="https://raw.githubusercontent.com/boycgit/web-image/master/blog20190621141038.png" alt="通过控制台查看 bundle.js 文件"></p>
<p>这样，我们就可以直接在 index.js 中粘贴我们需要的代码，因为基于 Webpack 打包，所以示例代码是可以运行的。</p>
<h2 id="5">5、分析转换之后的代码逻辑</h2>
<p>上述两种方法因为都是使用同一个装饰器转换插件 <a href="https://github.com/loganfsmyth/babel-plugin-transform-decorators-legacy">babel-plugin-transform-decorators-legacy</a>，所以<strong>装饰器语法部分转换后的代码是一样的</strong>。</p>
<p>比如针对 <code>price</code> 属性的装饰器语法：</p>
<pre><code class="language-js">@observable price = 0;
</code></pre>
<p>经过 babel 转译之后：</p>
<pre><code class="language-js">var _descriptor = _applyDecoratedDescriptor(
    _class.prototype,
    'price',
    [_mobx.observable],
    {
      enumerable: true,
      initializer: function initializer() {
        return 0;
      }
    }
  )
</code></pre>
<p>而对于 <code>total</code> 方法的装饰器语法：</p>
<pre><code class="language-js">@computed get total() {
    return this.price * this.amount;
}
</code></pre>
<p>经过 babel 转译之后则为：</p>
<pre><code class="language-js">_applyDecoratedDescriptor(
  _class.prototype,
  'total',
  [_mobx.computed],
  Object.getOwnPropertyDescriptor(_class.prototype, 'total'),
  _class.prototype
);
</code></pre>
<p><img src="https://raw.githubusercontent.com/boycgit/web-image/master/blog20190621141104.png" alt="关键的 _applyDecoratedDescriptor 函数"></p>
<p>可以看到关键是使用了 <code>_applyDecoratedDescriptor</code> 方法。接下来我们着重分析这个方法。</p>
<h2 id="6_applydecorateddescriptor">6、关键是 <code>_applyDecoratedDescriptor</code> 方法</h2>
<p>该函数签名为：</p>
<pre><code class="language-js">function _applyDecoratedDescriptor(
  target,
  property,
  decorators,
  descriptor,
  context
)
</code></pre>
<p>具体的用法，以 <code>price</code> 属性为例，我们可以获取对应的实参：</p>
<ul>
<li><strong>target</strong>：<code>_class.prototype</code> ，即 <code>OrderLine.prototype</code></li>
<li><strong>property</strong>：即字符串 <code>"price"</code></li>
<li><strong>decorators</strong>：在这里是 <code>[_mobx.observable]</code>（不同的修饰符装饰器是不一样的，比如使用 <code>@computed</code> 修饰的 <code>total</code> 方法，就是 <code>[_mobx.computed]</code>），是长度为 1 的数组，具体的 <code>observable</code> 方法将在下一篇文章详细讲，就是 <a href="https://github.com/mobxjs/mobx/blob/4.1.1/src/api/observable.ts#L68">createObservable</a></li>
<li><strong>descriptor</strong>：即属性描述符，属性成员（比如 <code>price</code>）会有 <code>initializer</code> 属性，而方法成员（比如 <code>total</code>） 则不会有这个属性，用这个来区分这两种不同属性描述符。</li>
</ul>
<pre><code class="language-js">{
  enumerable: true,
  initializer: function initializer() {
    return 0;
  }
}
</code></pre>
<ul>
<li><strong>context</strong>：就是运行上下文，一般来讲对数据属性的装饰则为 <code>null</code>，对方法属性则是 <code>_class.prototype</code>；</li>
</ul>
<p>看完函数签名，我们继续看函数内容：</p>
<p><img src="https://raw.githubusercontent.com/boycgit/web-image/master/blog20190621141133.png" alt="_applyDecoratedDescriptor 函数内容"></p>
<p>这几行代码没啥难度，就是我们熟悉的 <strong>属性描述符</strong> 相关的内容：</p>
<ul>
<li>
<p>图中标注 ① ，表示返回的 <code>desc</code> 变量就是我们熟悉的 <strong>属性描述符</strong>。因此，该 <code>_applyDecoratedDescriptor</code> 的作用就是根据入参返回具体的描述符。</p>
</li>
<li>
<p>如果是属性成员（比如<code>price</code>），就将返回的描述符就可以传给 <code>_initDefineProp</code> （相当于 <code>Object.defineProperty</code>）应用到原来的属性中去了，从而起到了 <strong>装饰</strong> 作用。<br>
<img src="https://raw.githubusercontent.com/boycgit/web-image/master/blog20190621141200.png" alt="如果是属性成员，则调用 _initDefineProp 方法"></p>
</li>
<li>
<p>图中标注 ② ，表示对于方法成员（比如 <code>total</code>）则直接应用 <code>Object.defineProperty</code> 方法（当是方法成员时，<code>desc</code> 是没有 <code>initializer</code> 属性的），同时令 desc = null，从后续的应用来看并不会和 <code>_initDefineProp</code> 方法搭配使用</p>
</li>
</ul>
<p>对于图中标注 ③ ，我们具体看<code>decorators</code> 在其中发挥的作用，典型的函数式编程手法：</p>
<p><img src="https://raw.githubusercontent.com/boycgit/web-image/master/blog20190621141326.png" alt="应用 decorators"></p>
<ul>
<li>首先整体上来看，是一个循环语句。假如我们传入的 <code>decorators</code> 是 <strong>[a, b, c]</strong>，那么上面的代码相当于应用公式 <code>a(b(c(property)))</code>，也就是装饰器 <code>c</code> 先装饰属性 <code>property</code>，随后再叠加装饰器 <code>b</code> 的作用，最后叠加装饰器 <code>a</code>。以 <code>price</code> 属性为例，由于只有一个装饰器（<strong>@observable</strong>），所以只应用了 <code>[_mobx.observable]</code> 这一个装饰器。</li>
<li>其次局部来看，装饰器具体应用表达式是 <code>decorator(target, property, desc)</code> ，其函数签名和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">Object.defineProperty</a> 是一模一样。通过图中标注 ③ 我们可以理解，当我们写装饰器函数函数时，函数的定义入参必须是 <code>(target, name, descriptor)</code> 这样的，同时该函数必须要返回属性描述符。（可以停下来去翻翻看自己写装饰器函数的那些例子）</li>
</ul>
<p>至此我们已经掌握了 babel 转换 <code>@</code> 语法的精髓 —— 创建了 <code>_applyDecoratedDescriptor</code> 方法，从而依次应用你所定义的装饰器方法，而且也明白了自定义的装饰器方法的函数签名必须是 <code>(target, name, descriptor)</code> 的。</p>
<p>总结一下这个 babel 插件对于装饰器语法 <code>@</code> 所做的事情：</p>
<ol>
<li>通过 ast 分析，将 <code>@</code> 语法转换成 <code>_applyDecoratedDescriptor</code> 方法的应用</li>
<li><code>_applyDecoratedDescriptor</code> 方法就是一个循环应用装饰器的过程</li>
</ol>
<p>那么接下来我们回到主题，mobx 如果不使用 babel 转译，那该如何实现类似于上述装饰器的语法呢？</p>
<h2 id="7mobx">7、不用装饰器语法，mobx 提供了等价写法</h2>
<p>很显然，MobX 不能实现（也没有必要）ast 分析将 <code>@</code> 语法转换掉的功能，所以只能提供 <strong>循环应用装饰器</strong> 的这方面的功能。</p>
<p>为达到这个目的，MobX 4.x 版本相对 3.x 等以前版本多了 <a href="https://cn.mobx.js.org/refguide/api.html#decorate">decorate</a> API 方法。</p>
<p>官方文档 <a href="https://cn.mobx.js.org/best/decorators.html">如何(不)使用装饰器</a> 所言，使用装饰器 <code>@</code> 语法等价于使用 <code>decorate</code> 方法，即改写成如下形式：</p>
<pre><code class="language-js">
import { observable, computed, decorate, action } from "mobx";

class OrderLine {
    price = 0;
    amount = 1;

    get total() {
        return this.price * this.amount;
    }
}
decorate(OrderLine, {
    price: observable,
    amount: observable,
    total: computed,
    increment: action.bound
})
</code></pre>
<blockquote>
<p>3.x 以前的版本因为没有 <code>decorate</code> 方法，所以是借助 <code>extendObservable</code> 方法实现的，具体见文档 <a href="https://github.com/SangKa/MobX-Docs-CN/tree/3.0.0/docs#%E6%8F%92%E6%9B%B2-%E5%9C%A8es5es6%E5%92%8Cesnext%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BD%BF%E7%94%A8-mobx">在ES5、ES6和ES.next环境下使用 MobX</a></p>
</blockquote>
<p>我们翻开 <a href="https://github.com/mobxjs/mobx/blob/4.1.1/src/api/decorate.ts#L11">decorate 源码</a>，该函数声明是：</p>
<pre><code class="language-js">decorate(thing, decorators)
</code></pre>
<ul>
<li><code>thing</code>：需要被装饰的原始对象；</li>
<li><code>decorators</code>：装饰器配置对象，是一个 <strong>key/value</strong> 形式的对象， <strong>key 是属性名，value 就是具体的装饰器函数</strong>（比如 <code>observable</code>、<code>computed</code> 和 <code>action.bound</code> 这样具体的装饰器有效函数）</li>
</ul>
<p>摘出核心语句：</p>
<p><img src="https://raw.githubusercontent.com/boycgit/web-image/master/blog20190621141427.png" alt="decorate 源码中的关键代码"></p>
<p>可以看去的确就是一个 <code>for</code> 循环，然后依次应用 <code>decorator</code>，这恰好就是 babel 插件转换后 <code>_applyDecoratedDescriptor</code> 方法所做的事情，因此两者是等效的。</p>
<p>这样，就解答了本文开篇提出的第一个疑问。 <a href="https://cn.mobx.js.org/refguide/observable-decorator.html">@observable</a>、<a href="https://cn.mobx.js.org/refguide/computed-decorator.html">@computer</a> 等装饰器语法，是和直接使用 <a href="https://cn.mobx.js.org/best/decorators.html">decorate</a> 是等效等价的。</p>
<p>看到这里是不是觉得有点儿不可思议？嗯，事实上装饰器应用的过程就这么的简单。你也可以直接将这个 <a href="https://cn.mobx.js.org/refguide/api.html#decorate">decorate</a> API 方法直接提取到自己的项目中使用，给你的项目增加新的 feature。</p>
<p>解答完第一个问题，我们继续讲本文开头提出的另一个问题：MobX 中的 <code>enhancer</code> 是什么概念？</p>
<h1 id="cenhancer">C. 理解 Enhancer</h1>
<h2 id="1enhancer">1、<strong>Enhancer</strong> 概念</h2>
<p><strong>Enhancer</strong> 这个概念是 MobX 自己提出的一个概念，刚接触到的用户大多数会先蒙圈一会儿。</p>
<p>学习过 MobX 3.x 及以前版本的人可能会遇到  <strong>Modifier</strong> 这个概念，<code>Enhancer</code> 其实就是 <code>Modifier</code>。</p>
<p><strong>Modifier</strong> 在 MobX 3 之前的版本里官方有专门的 <a href="https://github.com/SangKa/MobX-Docs-CN/blob/3.0.0/docs/refguide/modifiers.md">文档</a> 解说。不过到 MobX 4.x 之后官方就删除了这篇文档。好在这个概念是内部使用的，修改名字对外部调用者没有啥影响。</p>
<p><code>Enhancer</code> 从字面上理解是 <strong>增强器</strong>，其作用就是给原有的对象 <strong>增加额外的功能</strong> —— 这不就是装饰器的作用么？没错，它是辅助 MobX 中的 <code>@observable</code> 装饰器功能的。结合装饰器，会更加容易理解这个概念。</p>
<h2 id="2enhancerobservable">2、Enhancer 和 <code>@observable</code> 的整体关系</h2>
<p>MobX 不是有很多种装饰器么，比如 <code>@observable</code>、<code>@compute</code> 和 <code>@action</code>，注意 <code>Enhancer</code> 只和 <code>@observable</code> 有关系，和 <code>@compute</code> 和 <code>@action</code> 是没啥关系的。这是因为 <code>Enhancer</code> 是为观察值（observable）服务的，和计算值（computedValue）和动作（Action）没关系。</p>
<p><code>@observable</code> 装饰器中真正起作用的函数就是 <strong>Enhancer</strong> ，你可以将 <strong>Enhancer</strong> 理解成 <code>@observable</code> 装饰器有效的那部分。可以用 "药物胶囊💊" 来理解 <code>@observable</code> 装饰器和 <strong>Enhancer</strong> 的关系：</p>
<p><img src="https://raw.githubusercontent.com/boycgit/web-image/master/blog20190621141541.png" alt="形象类比 @observable 装饰器语法和 Enhancer 的关系"></p>
<ul>
<li><code>@observable</code> 装饰器就像是胶囊的外壳，内里携带的药物成分就是 <strong>Enhancer</strong>，因为真正起效果的部分是 <strong>Enhancer</strong></li>
<li>平时我们所接触到的 <code>@observable</code> 装饰器仅仅是起到包装、传输到指定目的地的作用。</li>
<li>从另一个角度来讲，在 mobx 代码实现中，<strong>Enhancer</strong> 是实现 Observable 观察值必不可少的一部分，没有它就实现不了观察值功能，也就构建不起 MobX 体系了；而如果缺失 <code>@observable</code> 相关的代码，顶多是不能使用装饰器功能而已。</li>
<li>这里还要特别强调一下，<strong>这里特指 <code>@observable</code> 装饰器是这种情况，其他的装饰器（包括 <code>@compute</code> 和 <code>@action</code> 这样的装饰器以及自己写的装饰器）都不在此讨论范畴</strong></li>
</ul>
<p>在 MobX 中<strong>有 4 种 Enhancer</strong>，在  <a href="https://github.com/mobxjs/mobx/blob/4.1.1/src/types/modifiers.ts">types/modifier.ts</a> 中有定义：</p>
<ul>
<li>deepEnhancer：默认的，也是最常用的，它会递归地在可观察对象的属性或可观察数组、Map 的元素上调用；</li>
<li>shallowEnhancer：不对传入的值进行转换，直接返回</li>
<li>referenceEnhancer：只转换 Object, Array, Map 本身，不对其属性（或元素）转换</li>
<li>refStructEnhancer：结构内容值发生改变的时候才进行数据更新</li>
</ul>
<p>不理解的话可以参考 <a href="https://zhuanlan.zhihu.com/p/31706219">Mobx 源码解读（三） Modifier</a> 文章，有详细的示例解说，本文就不展开了。</p>
<p>接下来，我们需要解决的是有两个问题：</p>
<ol>
<li><strong>Enhancer</strong> 是如何和 <code>@observable</code> 装饰器语法产生联系的？</li>
<li><strong>Enhancer</strong> 真正起作用是在什么地方？</li>
</ol>
<h2 id="3enhancerobservable">3、Enhancer 是如何运用到 <code>@observable</code> 装饰器语法中的？</h2>
<p>这个过程讲解起来有点儿绕。但我还是尽可能讲得明白一些吧。</p>
<p>返回看上面示例中：</p>
<pre><code class="language-js">@observable price = 0;
</code></pre>
<p>该装饰语法最终会换成 <code>_mobx.observable</code> 方法的调用。</p>
<p>我们看一下 <a href="https://github.com/mobxjs/mobx/blob/4.1.1/src/api/observable.ts#L201">observable 源码</a> ：</p>
<pre><code class="language-js">export const observable: IObservableFactory &amp;
    IObservableFactories &amp; {
        enhancer: IEnhancer&lt;any&gt;
    } = createObservable as any
</code></pre>
<p>会发现 <code>observable</code> 是函数，其函数内容就是 <a href="https://github.com/mobxjs/mobx/blob/4.1.1/src/api/observable.ts#L68">createObservable</a>。</p>
<p>因此上面示例中转义后的代码相当于：</p>
<pre><code class="language-js">return createObservable(OrderLine.prototype, 'price', desc);
</code></pre>
<p>继续看这个 <code>createObservable</code> 大体逻辑走向，该方法依据 <strong>第二个参数是否 string 类型</strong> 而起到不同的作用：</p>
<p><img src="https://raw.githubusercontent.com/boycgit/web-image/master/blog20190621141646.png" alt="createObservable方法内根据第二个参数进行不同的处理"></p>
<ul>
<li>如果第二个参数不是 string 类型，会走图中所示 ① 的逻辑，相当于 <strong>转换函数</strong>，将普通属性转换成 Observable 对象；这部分逻辑我们下一篇文章会着重讲到，这里暂且略过；</li>
<li>如果<strong>第二个参数是 string 类型</strong> ，那么就是本文所述起到 <strong>装饰器</strong> 作用，此时方法第二个入参必须是 <code>string</code>，从而会调用 <code>deepDecorator.apply(null, arguments)</code>，这是我们这篇文章要继续讲的内容。</li>
</ul>
<p>探究一下 <code>deepDecorator</code> 的来历：</p>
<pre><code class="language-js">const deepDecorator = createDecoratorForEnhancer(deepEnhancer)
</code></pre>
<p>通过给 <a href="https://github.com/mobxjs/mobx/blob/4.1.1/src/api/observabledecorator.ts#L11">createDecoratorForEnhancer</a> 方法传入 <code>deepEnhancer</code> 就可以了。从这个 <a href="https://github.com/mobxjs/mobx/blob/4.1.1/src/api/observabledecorator.ts#L11">createDecoratorForEnhancer</a> 方法的名字就能知道其含义，<strong>基于 enhancer 创建装饰器</strong>，是不是有点神奇，直接用 <strong>Enhancer</strong> 就能创建到对应的装饰器了！MobX 中其他 enhancer 也是基于这个函数创建相应的装饰器的：</p>
<p><img src="https://raw.githubusercontent.com/boycgit/web-image/master/blog20190621141737.png" alt="直接用 Enhancer 就能创建到对应的装饰器了"></p>
<p>这个过程就是 <code>@observable</code> 装饰器语法 和 enhancer 产生联系的地方。</p>
<h2 id="4enhancer">4、<strong>Enhancer</strong> 真正起作用是在什么地方？</h2>
<p>继续研究 <code>createDecoratorForEnhancer</code> 方法就能探知 <strong>Enhancer</strong> 起作用的地方。</p>
<p>不过接下来的函数分解，涉及到各种闭包来回整，很容易把人绕晕。这里做了一副简单的调用顺序图：</p>
<p><img src="https://raw.githubusercontent.com/boycgit/web-image/master/blog20190621141842.png" alt="用一副简单的调用顺序图来理解 createDecoratorForEnhancer 源码"></p>
<ul>
<li><code>createDecoratorForEnhancer</code> 里面会调用 <code>createPropDecorator</code> 和</li>
<li><code>createPropDecorator</code> 方法执行的时候会调用 <code>defineObservableProperty</code> 方法，<code>createPropDecorator</code> 是一个闭包，所以 <code>defineObservableProperty</code> 能在作用域中获知 <code>enhancer</code> 变量</li>
<li>在 <code>defineObservableProperty</code> 中会继续调用 <code>new ObservableValue</code> 创建观察值，创建的过程中会将 <code>enhancer</code> 作为参数传递进去。</li>
</ul>
<p>这里就不展开讲解，看得很晕也不用在意，有个大概了解就行。感兴趣的读者，可以挨个在源码中查找上述的函数名字，感受他们互相调用的关系，外加再看一下 <a href="https://github.com/mobxjs/mobx/blob/4.1.1/src/types/observableobject.ts#L247">defineObservableProperty</a> 源码就可以。</p>
<p>下一篇文章着重分析观察值（Observable）过程的时候，还会涉及这部分逻辑，这里我们知道大致的结论就行：<strong>最终的 <code>enhancer</code> 会传递给 <code>ObservableValue</code> 构造函数，从而影响观察值创建过程</strong>。</p>
<p>具体的影响在 <a href="https://github.com/mobxjs/mobx/blob/4.1.1/src/types/observablevalue.ts#L44"><code>ObservableValue</code></a> 的构造函数中就体现出来，直接影响观察值对象中的 <code>value</code> 属性：</p>
<pre><code class="language-js">this.value = enhancer(value, undefined, name)
</code></pre>
<p><img src="https://raw.githubusercontent.com/boycgit/web-image/master/blog20190621142003.png" alt="enhancer 在创建 observable 时发挥作用"></p>
<p>再结合 <a href="https://github.com/mobxjs/mobx/blob/4.1.1/src/types/modifiers.ts">types/modifier.ts</a> 中有各种 <strong>Enhancer</strong> 的具体内容，就能大致了解 enhancer 是如何起到 <strong>转换数值</strong> 的作用的，再分析下去就是观察值（<a href="https://cn.mobx.js.org/refguide/observable.html">Observable</a>）的内容了，因为里面涉及到 <strong>递归转换</strong> 的逻辑，所以我统一会放在下一篇文章中展开讲解。</p>
<h1 id="">本文小结</h1>
<p>在不用 babel 转义的情况下，mobx 通过提供<a href="https://cn.mobx.js.org/refguide/api.html#decorate">decorate</a> API 实现等价装饰器功能，原理也很简单：</p>
<ul>
<li>装饰器方法的函数签名必须是 <code>(target, property, desc)</code>（某种意义上已经成规范了）</li>
<li>先从对象中获取属性成员（或方法成员）的原始 <strong>属性描述符</strong></li>
<li>将属性描述符传给装饰器方法，获取更改后的 <strong>属性描述符</strong></li>
<li>通过 <code>Object.defineProperty</code> 将更改后的属性描述符 “安装” 回原始对象</li>
<li>若有多个装饰器，就循环上述过程。</li>
</ul>
<p>概括起来就是 <strong>循环应用装饰器方法</strong>，就是那么简单粗暴有效。</p>
<blockquote>
<p>可以看一下官方针对装饰器的<a href="https://cn.mobx.js.org/best/decorators.html">免责声明</a></p>
</blockquote>
<p>至于 <strong>Enhancer</strong>，它只影响观察值（Observable）的生成，不同的 <strong>Enhancer</strong> 会形成不同种类的观察值（Observable）；</p>
<p>正是因为 <strong>Enhancer</strong> 只影响观察值（Observable），所以和它相关的装饰器只有 <code>@observable</code>，与 <code>@computed</code> 以及 <code>@action</code> 等装饰器无关（不过装饰器方法的定义都大同小异，只是有效成分不一样罢了）。</p>
<p><strong>Enhancer</strong> 是如何和 <code>@observable</code> 装饰器语法产生联系的呢？答案是 <code>@observable</code> 转义后实际上就是调用 <code>deepDecorator</code> 函数，而该函数需要 <code>deepEnhancer</code> 作为 “原材料” 才能生成的，还是以 <strong>药物胶囊</strong> 为例来理解，<code>@observable</code> 就是一个壳，起到运输包装作用，真正起作用的仍旧是里面的 <strong>Enhancer</strong>。</p>
<p><strong>Enhancer</strong> 真正起作用地方，是在于经过一路的闭包转换沉淀，最终会 <strong>以参数的方式</strong> 传递给 <code>new Observable</code> 这个构造函数中，影响所生成的观察值。</p>
<p>本章所讲的内容稍微枯燥一些，也并非是 MobX 几大核心概念（Reaction、Observable、ComputedValue），然而所讲的装饰器知识一方面是理解 <code>@</code> 语法，另一方面也更好地阐述 <strong>Enhancer</strong> 的概念，这些都是为了给后续要讲的观察值（Observable）打基础。而且经过这一篇文章的讲解，你可以充分体会到装饰器的概念是如此地深入到 MobX 体系中，已俨然成为 MobX 体系中不可分割的一部分。</p>
<!--kg-card-end: markdown-->
                </div>
            </section>
            <p style="text-align: center">下面的是我的公众号二维码图片，欢迎关注，及时获取最新技术文章。</p>
            <section style="text-align: center"><img src="https://raw.githubusercontent.com/boycgit/web-image/master/blogqrcode2.jpg"></section>
            <script src="https://cdn.jsdelivr.net/npm/katex@0.10.0-beta/dist/katex.min.js" integrity="sha384-U8Vrjwb8fuHMt6ewaCy8uqeUXv4oitYACKdB0VziCerzt011iQ/0TqlSlv8MReCm" crossorigin="anonymous"></script>
            <script src="https://cdn.jsdelivr.net/npm/katex@0.10.0-beta/dist/contrib/auto-render.min.js" integrity="sha384-aGfk5kvhIq5x1x5YdvCp4upKZYnA8ckafviDpmWEKp4afOZEqOli7gqSnh8I6enH" crossorigin="anonymous"></script>


            <section id="gitalk-component-wrap"></section>

            <footer class="post-full-footer">


                    
<section class="author-card">
        <img class="author-profile-image" src="http://www.gravatar.com/avatar/8b26b02c66a0e37c2183431d58502c25?s=250&amp;d=mm&amp;r=x" alt="boycgit">
    <section class="author-card-content">
        <h4 class="author-card-name"><a href="../author/boycgit/">boycgit</a></h4>
            <p>阅读此作者的<a href="../author/boycgit/">更多文章</a>.</p>
    </section>
</section>
<div class="post-full-footer-right">
    <a class="author-card-button" href="../author/boycgit/">阅读更多</a>
</div>


            </footer>


        </article>

    </div>
</main>

<aside class="read-next outer">
    <div class="inner">
        <div class="read-next-feed">
                <article class="read-next-card" style="background-image: url(https://casper.ghost.org/v1.0.0/images/blog-cover.jpg)">
                    <header class="read-next-card-header">
                        <small class="read-next-card-header-sitetitle">— JSCON-简时空 —</small>
                        <h3 class="read-next-card-header-title"><a href="../tag/mobx/">mobx</a></h3>
                    </header>
                    <div class="read-next-divider"><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24"><path d="M13 14.5s2 3 5 3 5.5-2.463 5.5-5.5S21 6.5 18 6.5c-5 0-7 11-12 11C2.962 17.5.5 15.037.5 12S3 6.5 6 6.5s4.5 3.5 4.5 3.5"></path></svg>
</div>
                    <div class="read-next-card-content">
                        <ul>
                            <li><a href="../mobx-source-observable/">【用故事解读 MobX 源码（五）】 Observable</a></li>
                            <li><a href="../mobx-source-shouldcompute/">【用故事解读 MobX源码（三）】 shouldCompute</a></li>
                            <li><a href="../mobx-source-computed/">【用故事解读 MobX源码（二）】 computed</a></li>
                        </ul>
                    </div>
                    <footer class="read-next-card-footer">
                        <a href="../tag/mobx/">查看所有4篇文章 →</a>
                    </footer>
                </article>

                <article class="post-card post tag-mobx tag-javascript tag-yuan-ma-fen-xi tag-yuan-ma">
        <a class="post-card-image-link" href="../mobx-source-observable/">
            <div class="post-card-image" style="background-image: url(https://images.unsplash.com/photo-1525433752067-f98594fb10f4?ixlib=rb-0.3.5&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=1080&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ&amp;s=0294b05c2cb04b4032abcd4b937e3bbf)"></div>
        </a>
    <div class="post-card-content">
        <a class="post-card-content-link" href="../mobx-source-observable/">
            <header class="post-card-header">
                    <span class="post-card-tags">mobx</span>
                <h2 class="post-card-title">【用故事解读 MobX 源码（五）】 Observable</h2>
            </header>
            <section class="post-card-excerpt">
                <p>网上已有很多关于 MobX 源码解读的文章，但大多阅读成本甚高。本人在找文章时对此深有体会，故将以系列故事的方式展现源码逻辑，尽可能以易懂的方式讲解 MobX 源码；本文分析源码中有关 Observable 的执行逻辑</p>
            </section>
        </a>
        <footer class="post-card-meta">

            <ul class="author-list">
                <li class="author-list-item">

                    <div class="author-name-tooltip">
                        boycgit
                    </div>

                        <a href="../author/boycgit/" class="static-avatar"><img class="author-profile-image" src="http://www.gravatar.com/avatar/8b26b02c66a0e37c2183431d58502c25?s=250&amp;d=mm&amp;r=x" alt="boycgit"></a>
                </li>
            </ul>

            <span class="reading-time">阅读耗时约 32 分钟</span>

        </footer>
    </div>
</article>

                <article class="post-card post tag-mobx tag-javascript tag-yuan-ma-fen-xi tag-yuan-ma">
        <a class="post-card-image-link" href="../mobx-source-shouldcompute/">
            <div class="post-card-image" style="background-image: url(https://images.unsplash.com/photo-1523240524572-9fa79064364a?ixlib=rb-0.3.5&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=1080&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ&amp;s=6da5ce196c64ceaebce9ec6f3640f787)"></div>
        </a>
    <div class="post-card-content">
        <a class="post-card-content-link" href="../mobx-source-shouldcompute/">
            <header class="post-card-header">
                    <span class="post-card-tags">mobx</span>
                <h2 class="post-card-title">【用故事解读 MobX源码（三）】 shouldCompute</h2>
            </header>
            <section class="post-card-excerpt">
                <p>网上已有很多关于 MobX 源码解读的文章，但大多阅读成本甚高。本人在找文章时对此深有体会，故将以系列故事的方式展现源码逻辑，尽可能以易懂的方式讲解 MobX 源码；本文分析 shouldCompute 源码的执行逻辑</p>
            </section>
        </a>
        <footer class="post-card-meta">

            <ul class="author-list">
                <li class="author-list-item">

                    <div class="author-name-tooltip">
                        boycgit
                    </div>

                        <a href="../author/boycgit/" class="static-avatar"><img class="author-profile-image" src="http://www.gravatar.com/avatar/8b26b02c66a0e37c2183431d58502c25?s=250&amp;d=mm&amp;r=x" alt="boycgit"></a>
                </li>
            </ul>

            <span class="reading-time">阅读耗时约 21 分钟</span>

        </footer>
    </div>
</article>

        </div>
    </div>
</aside>

<div class="floating-header">
    <div class="floating-header-logo">
        <a href="https://boycgit.github.io">
                <img src="../content/images/2018/08/logo.png" alt="JSCON-简时空 icon">
            <span>JSCON-简时空</span>
        </a>
    </div>
    <span class="floating-header-divider">—</span>
    <div class="floating-header-title">【用故事解读 MobX 源码（四）】装饰器 和 Enhancer</div>
    <div class="floating-header-share">
        <div class="floating-header-share-label">分享 <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24">
    <path d="M7.5 15.5V4a1.5 1.5 0 1 1 3 0v4.5h2a1 1 0 0 1 1 1h2a1 1 0 0 1 1 1H18a1.5 1.5 0 0 1 1.5 1.5v3.099c0 .929-.13 1.854-.385 2.748L17.5 23.5h-9c-1.5-2-5.417-8.673-5.417-8.673a1.2 1.2 0 0 1 1.76-1.605L7.5 15.5zm6-6v2m-3-3.5v3.5m6-1v2"></path>
</svg>
</div>
        <a class="floating-header-share-weibo" href="http://service.weibo.com/share/share.php?title=%E7%9C%8B%E5%88%B0%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E3%80%8A%E3%80%90%E7%94%A8%E6%95%85%E4%BA%8B%E8%A7%A3%E8%AF%BB%20MobX%20%E6%BA%90%E7%A0%81%EF%BC%88%E5%9B%9B%EF%BC%89%E3%80%91%E8%A3%85%E9%A5%B0%E5%99%A8%20%E5%92%8C%20Enhancer%E3%80%8B%EF%BC%8C%E5%BE%88%E7%B2%BE%E5%BD%A9%EF%BC%8C%E6%83%B3%E5%88%86%E4%BA%AB%E7%BB%99%E5%A4%A7%E4%BC%99%E5%84%BF&amp;url=https://boycgit.github.io/mobx-source-enhancer/" onclick="window.open(this.href, 'share-weibo', 'width=550,height=235');return false;">
            <?xml version="1.0" standalone="no"?><svg t="1534600204727" class="icon" style="" viewbox="0 0 1026 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4202" xmlns:xlink="http://www.w3.org/1999/xlink" width="16.03125" height="16"><defs><style type="text/css"></style></defs><path d="M1012.49 451.553v0.159c-6.697 20.66-28.861 31.99-49.449 25.288a39.352 39.352 0 0 1-25.287-49.582l-0.067-0.031c20.536-63.6 7.516-136.156-40.315-189.363-47.892-53.212-118.502-73.554-183.731-59.659-21.222 4.537-42.133-9.047-46.638-30.3-4.506-21.253 9.021-42.194 30.239-46.73 91.709-19.563 191.114 8.98 258.467 83.881 67.36 74.839 85.515 176.85 56.781 266.337z" fill="#ffffff" p-id="4203"></path><path d="M740.429 304.348v-0.03c-18.217 3.973-36.178-7.732-40.06-26.01-3.947-18.31 7.763-36.373 25.98-40.254 44.692-9.548 93.143 4.322 125.885 40.781 32.866 36.496 41.631 86.17 27.607 129.772a33.833 33.833 0 0 1-42.562 21.847c-17.782-5.76-27.484-24.914-21.724-42.69h-0.062c6.887-21.346 2.565-45.635-13.46-63.473-16.026-17.818-39.752-24.546-61.604-19.943z m30.05 192.184c-14.46-4.352-24.352-7.326-16.774-26.352 16.333-41.313 18.027-76.964 0.317-102.385-33.31-47.734-124.451-45.133-228.838-1.28 0-0.061-32.799 14.367-24.412-11.704 16.056-51.774 13.645-95.186-11.361-120.192-56.658-56.878-207.304 2.12-336.477 131.64C56.187 463.32 0 566.14 0 655.1 0 825.18 217.503 928.594 430.28 928.594c278.917 0 464.527-162.504 464.527-291.59 0-77.936-65.546-122.193-124.329-140.472zM430.842 867.62c-169.774 16.84-316.35-60.155-327.368-171.96-11.049-111.74 117.72-216.034 287.488-232.873 169.805-16.84 316.355 60.16 327.368 171.904 11.018 111.866-117.683 216.09-287.488 232.929z" fill="#ffffff" p-id="4204"></path><path d="M447.805 548.859c-80.783-21.09-172.119 19.287-207.206 90.65-35.743 72.862-1.188 153.681 80.44 180.1 84.578 27.357 184.233-14.525 218.88-93.148 34.181-76.81-8.478-155.94-92.114-177.602zM386.12 734.792c-16.43 26.29-51.584 37.806-78.065 25.661-26.107-11.889-33.833-42.44-17.403-68.045 16.215-25.538 50.207-36.869 76.498-25.856 26.604 11.392 35.087 41.687 18.97 68.24z" fill="#ffffff" p-id="4205"></path></svg>        </a>
        <a class="floating-header-share-weixin" href="https://cli.im/api/qrcode/code?text=https://boycgit.github.io/mobx-source-enhancer/&amp;mhid=txbODQq7nZkhMHcqI9xROqg" onclick="window.open(this.href, 'share-weixin','width=480,height=600');return false;">
            <?xml version="1.0" standalone="no"?><svg t="1534604253879" class="icon" style="" viewbox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5477" xmlns:xlink="http://www.w3.org/1999/xlink" width="16" height="16"><defs><style type="text/css"></style></defs><path d="M693.12 347.232c11.776 0 23.36 0.896 35.008 2.176C696.768 203.36 540.672 94.88 362.432 94.88 163.2 94.88 0 230.624 0 403.104c0 99.521 54.272 181.248 145.024 244.736L108.8 756.832l126.72-63.488c45.312 8.896 81.664 18.112 126.912 18.112 11.393 0 22.656-0.513 33.792-1.345-7.04-24.256-11.199-49.6-11.199-76.031C385.088 475.744 521.024 347.232 693.12 347.232zM498.304 248.992c27.393 0 45.376 17.984 45.376 45.248 0 27.136-17.983 45.312-45.376 45.312-27.071 0-54.336-18.176-54.336-45.312C443.968 266.912 471.168 248.992 498.304 248.992zM244.672 339.552c-27.2 0-54.592-18.176-54.592-45.312 0-27.264 27.392-45.248 54.592-45.248 27.2 0 45.248 17.92 45.248 45.248C289.92 321.376 271.872 339.552 244.672 339.552z" p-id="5478" fill="#ffffff"></path><path d="M1024 629.728c0-144.896-145.023-262.976-307.904-262.976-172.479 0-308.224 118.144-308.224 262.976 0 145.28 135.808 262.977 308.224 262.977 36.097 0 72.513-9.024 108.736-18.112l99.392 54.528-27.264-90.624C969.729 783.84 1024 711.456 1024 629.728zM616.128 584.352c-17.984 0-36.224-17.92-36.224-36.224 0-18.048 18.239-36.225 36.224-36.225 27.521 0 45.376 18.177 45.376 36.225C661.504 566.432 643.648 584.352 616.128 584.352zM815.488 584.352c-17.856 0-36.032-17.92-36.032-36.224 0-18.048 18.112-36.225 36.032-36.225 27.264 0 45.376 18.177 45.376 36.225C860.864 566.432 842.752 584.352 815.488 584.352z" p-id="5479" fill="#ffffff"></path></svg>        </a>
    </div>
    <progress id="reading-progress" class="progress" value="0">
        <div class="progress-container">
            <span class="progress-bar"></span>
        </div>
    </progress>
</div>



<script src="https://cdn.jsdelivr.net/npm/gitalk@1.3.3/dist/gitalk.min.js"></script>

<script>
    (function () {
        /**
         * Get Node
         * @param  {String|Element} el
         * @param  {Boolean} noCache
         * @return {Element}
         */
        var cacheNode = {};
        function getNode(el, noCache) {
            if (noCache === void 0) noCache = false;

            if (typeof el === 'string') {
                if (typeof window.Vue !== 'undefined') {
                    return find(el);
                }
                el = noCache ? find(el) : cacheNode[el] || (cacheNode[el] = find(el));
            }

            return el;
        }

        /**
         * Find element
         * @example
         * find('nav') => document.querySelector('nav')
         * find(nav, 'a') => nav.querySelector('a')
         */
        function find(el, node) {
            return node ? el.querySelector(node) : document.querySelector(el);
        }
        function create(node, tpl) {
            node = document.createElement(node);
            if (tpl) {
                node.innerHTML = tpl;
            }
            return node;
        }
        function appendTo(target, el) {
            return target.appendChild(el);
        }

        function renderGitalkContainer() {
            var div = create('div');
            div.id = 'gitalk-container';
            var main = getNode('#site-main');
            div.style = 'width: ' + main.clientWidth + 'px; margin: 0 auto 20px;';
            appendTo(find('#gitalk-component-wrap'), div);
            var script = create('script');
            var content = "gitalk.render('gitalk-container')";
        }
        renderGitalkContainer();

        var gitalk = new Gitalk({
            clientID: 'a65ee9e3ea5168da1470',
            clientSecret: 'ebfd520679d1ad61929b1887b2efccd4872389e3',
            repo: 'boycgit.github.io',
            owner: 'boycgit',
            admin: [
                'boycgit'
            ],
            id: location.pathname,
            // facebook-like distraction free mode
            distractionFreeMode: false
        });
        gitalk.render('gitalk-container');



        var postImages = document.querySelectorAll('.post-content img');
        Array.prototype.forEach.call(postImages, function (el, i) {
            el.outerHTML = `<aholder href="${el.src}" data-lightbox="postImages" data-title="${el.alt}">${el.outerHTML}</aholder>`.replace(/aholder/g, 'a');
        });

        // 动态添加 js 脚本
        setTimeout(function(){
            var script = document.createElement("script");
            script.type = "text/javascript";
            script.src = "https://cdn.jsdelivr.net/npm/lightbox2@2.10.0/dist/js/lightbox.min.js";
            document.getElementsByTagName('body')[0].appendChild(script);

            script.onload = function () {

                console.log('load success');
            }
        }, 1000);

    })();
</script>


        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="https://boycgit.github.io">JSCON-简时空</a> © 2019</section>
                <nav class="site-footer-nav">
                    <a href="https://boycgit.github.io">最新文章</a>
                    
                    
                    <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a>
                </nav>
            </div>
        </footer>

    </div>


    <script src="https://code.jquery.com/jquery-3.2.1.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous">
    </script>
    <script type="text/javascript" src="../assets/js/jquery.fitvids.js?v=a3b4af4713"></script>


    <script>

// NOTE: Scroll performance is poor in Safari
// - this appears to be due to the events firing much more slowly in Safari.
//   Dropping the scroll event and using only a raf loop results in smoother
//   scrolling but continuous processing even when not scrolling
$(document).ready(function () {
    // Start fitVids
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
    // End fitVids

    var progressBar = document.querySelector('#reading-progress');
    var header = document.querySelector('.floating-header');
    var title = document.querySelector('.post-full-title');

    var lastScrollY = window.scrollY;
    var lastWindowHeight = window.innerHeight;
    var lastDocumentHeight = $(document).height();
    var ticking = false;

    function onScroll() {
        lastScrollY = window.scrollY;
        requestTick();
    }

    function onResize() {
        lastWindowHeight = window.innerHeight;
        lastDocumentHeight = $(document).height();
        requestTick();
    }

    function requestTick() {
        if (!ticking) {
            requestAnimationFrame(update);
        }
        ticking = true;
    }

    function update() {
        var trigger = title.getBoundingClientRect().top + window.scrollY;
        var triggerOffset = title.offsetHeight + 35;
        var progressMax = lastDocumentHeight - lastWindowHeight;

        // show/hide floating header
        if (lastScrollY >= trigger + triggerOffset) {
            header.classList.add('floating-active');
        } else {
            header.classList.remove('floating-active');
        }

        progressBar.setAttribute('max', progressMax);
        progressBar.setAttribute('value', lastScrollY);

        ticking = false;
    }

    window.addEventListener('scroll', onScroll, {passive: true});
    window.addEventListener('resize', onResize, false);

    update();

});
</script>


    <script>
  document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body);
  });
</script>

</body>
</html>
